/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/ts/api.ts":
/*!***********************!*\
  !*** ./src/ts/api.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   api: () => (/* binding */ api),\n/* harmony export */   getAvatarUrl: () => (/* binding */ getAvatarUrl)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// API URL configuration\nconst API_URL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'\n    ? 'http://localhost:3000'\n    : window.location.origin; // Use the same origin in production\n// Helper for API requests\nfunction request(endpoint_1) {\n    return __awaiter(this, arguments, void 0, function* (endpoint, options = {}) {\n        try {\n            const url = `${API_URL}${endpoint}`;\n            console.log(`[API] Making ${options.method || 'GET'} request to: ${url}`);\n            // Get the most up-to-date token\n            const authService = window.authService;\n            let token;\n            if (authService && authService.getToken) {\n                // Get the token directly from auth service if available\n                token = authService.getToken();\n                console.log(`[API] Got token from authService: ${!!token}`);\n            }\n            else {\n                // Fallback to localStorage\n                token = localStorage.getItem('auth_token');\n                console.log(`[API] Got token from localStorage: ${!!token}`);\n            }\n            // Prepare headers - don't set Content-Type for FormData\n            const headers = Object.assign({ 'Accept': 'application/json' }, (token && { 'Authorization': `Bearer ${token}` }));\n            // Only set Content-Type if not FormData\n            if (!(options.body instanceof FormData)) {\n                headers['Content-Type'] = 'application/json';\n            }\n            // Add custom headers\n            Object.assign(headers, options.headers || {});\n            // Add a timeout to the fetch request\n            const controller = new AbortController();\n            const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout\n            const response = yield fetch(url, Object.assign(Object.assign({}, options), { headers, mode: 'cors', credentials: 'include', signal: controller.signal }));\n            clearTimeout(timeoutId); // Clear the timeout\n            console.log(`[API] Response status: ${response.status}`);\n            // Handle authentication errors\n            if (response.status === 401) {\n                console.log('[API] Authentication error (401) received');\n                // Use the auth service to clear the session if available\n                if (authService && authService.clearSession) {\n                    console.log('[API] Using authService to clear session');\n                    authService.clearSession();\n                }\n                else {\n                    // Fallback manual cleanup\n                    console.log('[API] Manually clearing auth data from storage');\n                    localStorage.removeItem('auth_token');\n                    localStorage.removeItem('user_id');\n                    localStorage.removeItem('username');\n                    localStorage.removeItem('avatar_url');\n                    sessionStorage.removeItem('auth_token');\n                    sessionStorage.removeItem('user_id');\n                    sessionStorage.removeItem('username');\n                    sessionStorage.removeItem('avatar_url');\n                }\n                // Get the current path and check if we need to redirect\n                const currentPath = window.location.pathname;\n                // Don't redirect if already on login page to avoid redirect loop\n                if (!currentPath.includes('login') && !currentPath.includes('register')) {\n                    console.log('[API] Redirecting to login page due to 401 error');\n                    window.location.href = '/login.html';\n                }\n                else {\n                    console.log('[API] Already on login/register page, not redirecting');\n                }\n                return {\n                    success: false,\n                    message: 'Authentication required'\n                };\n            }\n            // Handle 404 errors\n            if (response.status === 404) {\n                console.warn(`[API] Endpoint not found: ${endpoint}`);\n                return {\n                    success: false,\n                    message: `Endpoint not found: ${endpoint}`,\n                    data: [] // Renvoyer un tableau vide par d√©faut\n                };\n            }\n            // Handle no content response\n            if (response.status === 204) {\n                return { success: true };\n            }\n            let data;\n            try {\n                const text = yield response.text();\n                data = text ? JSON.parse(text) : {};\n            }\n            catch (error) {\n                console.error('Error parsing response:', error);\n                return {\n                    success: false,\n                    message: 'Failed to parse server response'\n                };\n            }\n            if (!response.ok) {\n                return {\n                    success: false,\n                    message: data.message || 'An error occurred'\n                };\n            }\n            return data;\n        }\n        catch (error) {\n            console.error('API request failed:', error);\n            if (error instanceof TypeError && error.message === 'Failed to fetch') {\n                console.warn('[API] Failed to fetch. The backend server may be down or unreachable.');\n                // Show a user-friendly message in the console that could be displayed to the user\n                console.log('[API] Connection to server failed. Please check if the backend is running.');\n            }\n            return {\n                success: false,\n                message: error instanceof Error ? error.message : 'Unknown error',\n                data: [] // Return an empty array by default\n            };\n        }\n    });\n}\n// Helper function to get avatar URL\nfunction getAvatarUrl(user) {\n    // Prioritize uploaded avatar data over URL\n    if (user.has_avatar_data) {\n        return `${API_URL}/users/avatar/${user.id}`;\n    }\n    // Fall back to avatar URL if available\n    if (user.avatar_url) {\n        return user.avatar_url;\n    }\n    // Return empty string - let the UI handle the default\n    return '';\n}\n// Create and export API object\nconst api = {\n    baseUrl: API_URL,\n    // Auth services\n    auth: {\n        login(email, password) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/auth/login', {\n                    method: 'POST',\n                    body: JSON.stringify({ email, password })\n                });\n            });\n        },\n        register(username, email, password) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/auth/register', {\n                    method: 'POST',\n                    body: JSON.stringify({ username, email, password })\n                });\n            });\n        },\n        logout() {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/auth/logout', {\n                    method: 'POST'\n                });\n            });\n        }\n    },\n    // User services\n    user: {\n        getProfile() {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/users/profile'); // Use /users/profile instead of /users/${id}\n            });\n        },\n        updateProfile(data) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/users/profile', {\n                    method: 'PUT', // Use PUT instead of PATCH to match backend\n                    body: JSON.stringify(data)\n                });\n            });\n        },\n        deleteProfile() {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/users/profile', {\n                    method: 'DELETE'\n                });\n            });\n        },\n        getMatches() {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/users/matches');\n            });\n        },\n        getAll() {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/users');\n            });\n        },\n        searchUsers(username) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request(`/users/search?username=${encodeURIComponent(username)}`);\n            });\n        },\n        checkUsername(username) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request(`/users/check-username?username=${encodeURIComponent(username)}`);\n            });\n        },\n        // New avatar methods\n        uploadAvatar(file) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const formData = new FormData();\n                formData.append('file', file);\n                return request('/users/profile/avatar', {\n                    method: 'POST',\n                    body: formData\n                });\n            });\n        },\n        deleteAvatar() {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/users/profile/avatar', {\n                    method: 'DELETE'\n                });\n            });\n        }\n    },\n    // Friendship services\n    friendship: {\n        getFriends() {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/friendships');\n            });\n        },\n        getPendingRequests() {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/friendships/requests');\n            });\n        },\n        sendFriendRequest(friendId) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/friendships/request', {\n                    method: 'POST',\n                    body: JSON.stringify({ friend_id: friendId })\n                });\n            });\n        },\n        acceptFriendRequest(requestId) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request(`/friendships/accept/${requestId}`, {\n                    method: 'POST',\n                    body: JSON.stringify({})\n                });\n            });\n        },\n        rejectFriendRequest(requestId) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request(`/friendships/reject/${requestId}`, {\n                    method: 'POST',\n                    body: JSON.stringify({})\n                });\n            });\n        },\n        removeFriend(friendId) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request(`/friendships/${friendId}`, {\n                    method: 'DELETE'\n                });\n            });\n        }\n    },\n    // Game services\n    game: {\n        getAllMatches() {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/game/matches');\n            });\n        }\n    },\n    // Chat services\n    chat: {\n        getMessages(userId) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request(`/chat/messages/${userId}`);\n            });\n        },\n        getUnreadCount() {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/chat/unread');\n            });\n        },\n        blockUser(userId) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/chat/block', {\n                    method: 'POST',\n                    body: JSON.stringify({ blocked_id: userId })\n                });\n            });\n        },\n        unblockUser(userId) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request(`/chat/block/${userId}`, {\n                    method: 'DELETE'\n                });\n            });\n        },\n        getBlockedUsers() {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/chat/blocks');\n            });\n        }\n    }\n};\n// Pour la r√©trocompatibilit√©, on expose aussi API globalement\nif (typeof window !== 'undefined') {\n    window.api = api;\n    window.getAvatarUrl = getAvatarUrl;\n}\n\n\n//# sourceURL=webpack://ft-transcendence-frontend/./src/ts/api.ts?");

/***/ }),

/***/ "./src/ts/chat.ts":
/*!************************!*\
  !*** ./src/ts/chat.ts ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChatManager: () => (/* binding */ ChatManager),\n/* harmony export */   chatManager: () => (/* binding */ chatManager)\n/* harmony export */ });\n/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api */ \"./src/ts/api.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// Chat functionality - Syst√®me de chat modulaire simplifi√© et robuste\n\n// Utility function to create avatar HTML with consistent styling\nfunction createAvatarHTML(user, size = 'medium') {\n    const sizeClasses = {\n        small: 'w-8 h-8',\n        medium: 'w-10 h-10',\n        large: 'w-12 h-12'\n    };\n    const iconSizes = {\n        small: 'text-sm',\n        medium: 'text-lg',\n        large: 'text-xl'\n    };\n    const sizeClass = sizeClasses[size];\n    const iconSize = iconSizes[size];\n    // Use getAvatarUrl to prioritize uploaded avatars over URLs\n    let avatarUrl = '';\n    if (user.id) {\n        avatarUrl = (0,_api__WEBPACK_IMPORTED_MODULE_0__.getAvatarUrl)({\n            id: user.id,\n            has_avatar_data: user.has_avatar_data,\n            avatar_url: user.avatar_url || undefined\n        });\n    }\n    if (avatarUrl && avatarUrl.trim()) {\n        return `<img src=\"${avatarUrl}\" alt=\"${user.username}\" class=\"w-full h-full object-cover\" onerror=\"this.style.display='none'; this.nextElementSibling.style.display='flex';\">\n                <i class=\"fas fa-user text-white ${iconSize}\" style=\"display: none;\"></i>`;\n    }\n    else {\n        return `<i class=\"fas fa-user text-white ${iconSize}\"></i>`;\n    }\n}\n// Blocking system manager - Version simplifi√©e et fiable\nclass BlockingManager {\n    constructor() {\n        this.blockedUsers = new Set();\n        this.blockedByUsers = new Set();\n        this.isLoading = false;\n        this.blockingWebSocketSetup = false;\n        this.loadBlockedUsers();\n        this.setupWebSocketHandlers();\n    }\n    setupWebSocketHandlers() {\n        const websocketService = window.websocketService;\n        if (!websocketService) {\n            console.warn('‚ö†Ô∏è WebSocket service not available for blocking system');\n            return;\n        }\n        // Check if handlers are already setup to avoid conflicts\n        if (this.blockingWebSocketSetup) {\n            console.log('üîå Blocking WebSocket handlers already setup, skipping');\n            return;\n        }\n        console.log('üîå Setting up blocking WebSocket handlers');\n        // Listen for successful block confirmation\n        websocketService.on('user-block-success', (data) => {\n            console.log('‚úÖ Block confirmed via WebSocket:', data);\n            this.blockedUsers.add(data.blocked_id);\n            // Update chat interface if currently viewing this user\n            const chatManager = window.chatManager;\n            if (chatManager && chatManager.getCurrentChatUserId() === data.blocked_id) {\n                console.log('üîÑ Updating chat interface after block');\n                chatManager.showBlockedInterface(data.blocked_id, data.blocked_username, true);\n            }\n        });\n        // Listen for successful unblock confirmation\n        websocketService.on('user-unblock-success', (data) => {\n            console.log('‚úÖ Unblock confirmed via WebSocket:', data);\n            this.blockedUsers.delete(data.unblocked_id);\n            // Force immediate chat interface refresh\n            const chatManager = window.chatManager;\n            if (chatManager && chatManager.getCurrentChatUserId() === data.unblocked_id) {\n                console.log('üîÑ Refreshing chat interface after unblock');\n                // Clear the blocked interface and reload chat properly\n                chatManager.forceRefreshChat(data.unblocked_id, data.unblocked_username);\n            }\n        });\n        // Listen for being blocked by someone\n        websocketService.on('user-blocked-by', (data) => {\n            console.log('üö´ Blocked by user via WebSocket:', data);\n            this.blockedByUsers.add(data.blocker_id);\n            // If currently chatting with this user, show blocked interface\n            const chatManager = window.chatManager;\n            if (chatManager && chatManager.getCurrentChatUserId() === data.blocker_id) {\n                chatManager.showBlockedInterface(data.blocker_id, data.blocker_username, false);\n            }\n        });\n        // Listen for being unblocked by someone\n        websocketService.on('user-unblocked-by', (data) => {\n            console.log('‚úÖ Unblocked by user via WebSocket:', data);\n            this.blockedByUsers.delete(data.unblocker_id);\n            // If currently viewing this user's chat, refresh it immediately\n            const chatManager = window.chatManager;\n            if (chatManager && chatManager.getCurrentChatUserId() === data.unblocker_id) {\n                console.log('üîÑ Refreshing chat interface after being unblocked');\n                chatManager.forceRefreshChat(data.unblocker_id, data.unblocker_username);\n            }\n        });\n        this.blockingWebSocketSetup = true;\n    }\n    loadBlockedUsers() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.isLoading) {\n                console.log('‚è≥ Already loading blocked users, skipping');\n                return;\n            }\n            this.isLoading = true;\n            try {\n                const response = yield _api__WEBPACK_IMPORTED_MODULE_0__.api.chat.getBlockedUsers();\n                if (response.success && response.data) {\n                    this.blockedUsers.clear();\n                    this.blockedByUsers.clear();\n                    const currentUserId = this.getCurrentUserId();\n                    if (!currentUserId)\n                        return;\n                    response.data.forEach((block) => {\n                        if (block.blocker_id === currentUserId) {\n                            this.blockedUsers.add(block.blocked_id);\n                        }\n                        else if (block.blocked_id === currentUserId) {\n                            this.blockedByUsers.add(block.blocker_id);\n                        }\n                    });\n                    console.log(`üìõ ${this.blockedUsers.size} blocked, ${this.blockedByUsers.size} blocked by`);\n                }\n            }\n            catch (error) {\n                console.error('‚ùå Error loading blocked users:', error);\n            }\n            finally {\n                this.isLoading = false;\n            }\n        });\n    }\n    blockUser(userId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const websocketService = window.websocketService;\n                // Try WebSocket first - NO optimistic updates\n                if (websocketService && websocketService.isConnected && websocketService.isConnected()) {\n                    console.log(`üö´ Blocking user ${userId} via WebSocket`);\n                    websocketService.send('user-block', { blockedUserId: userId });\n                    return true;\n                }\n                else {\n                    // Fallback to REST API\n                    console.log(`üö´ Blocking user ${userId} via REST API`);\n                    const response = yield _api__WEBPACK_IMPORTED_MODULE_0__.api.chat.blockUser(userId);\n                    if (response.success) {\n                        // Only update state after successful API response\n                        this.blockedUsers.add(userId);\n                        console.log(`‚úÖ User ${userId} blocked via REST API`);\n                        return true;\n                    }\n                    else {\n                        return false;\n                    }\n                }\n            }\n            catch (error) {\n                console.error('‚ùå Error blocking user:', error);\n                return false;\n            }\n        });\n    }\n    unblockUser(userId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.isBlocked(userId)) {\n                console.log(`‚ÑπÔ∏è User ${userId} is not blocked, skipping unblock`);\n                return true;\n            }\n            try {\n                const websocketService = window.websocketService;\n                // Try WebSocket first - NO optimistic updates\n                if (websocketService && websocketService.isConnected && websocketService.isConnected()) {\n                    console.log(`‚úÖ Unblocking user ${userId} via WebSocket`);\n                    websocketService.send('user-unblock', { unblockedUserId: userId });\n                    return true;\n                }\n                else {\n                    // Fallback to REST API\n                    console.log(`‚úÖ Unblocking user ${userId} via REST API`);\n                    const response = yield _api__WEBPACK_IMPORTED_MODULE_0__.api.chat.unblockUser(userId);\n                    if (response.success) {\n                        // Only update state after successful API response\n                        this.blockedUsers.delete(userId);\n                        console.log(`‚úÖ User ${userId} unblocked via REST API`);\n                        return true;\n                    }\n                    else {\n                        console.error('‚ùå REST API unblock failed:', response);\n                        return false;\n                    }\n                }\n            }\n            catch (error) {\n                console.error('‚ùå Error unblocking user:', error);\n                return false;\n            }\n        });\n    }\n    isBlocked(userId) {\n        return this.blockedUsers.has(userId);\n    }\n    isBlockedBy(userId) {\n        return this.blockedByUsers.has(userId);\n    }\n    canChat(userId) {\n        return !this.isBlocked(userId) && !this.isBlockedBy(userId);\n    }\n    getCurrentUserId() {\n        // Try to get from auth service first\n        const authService = window.authService;\n        if (authService === null || authService === void 0 ? void 0 : authService.getUserId) {\n            const userId = parseInt(authService.getUserId());\n            if (!isNaN(userId))\n                return userId;\n        }\n        const userIdStr = localStorage.getItem('user_id');\n        if (userIdStr) {\n            const userId = parseInt(userIdStr);\n            if (!isNaN(userId))\n                return userId;\n        }\n        return null;\n    }\n}\nclass ChatManager {\n    constructor() {\n        this.currentChatUserId = null;\n        this.currentChatUsername = null;\n        this.chatHistory = new Map();\n        this.chatWebSocketSetup = false;\n        this.chatHistory = new Map();\n        this.currentChatUserId = null;\n        this.blockingManager = new BlockingManager();\n        // Initialize blocking system\n        this.initializeBlockingSystem();\n        this.initializeChatEventListeners();\n        this.setupChatWebSocket();\n    }\n    initializeBlockingSystem() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield this.blockingManager.loadBlockedUsers();\n                console.log('‚úÖ Blocking system initialized');\n            }\n            catch (error) {\n                console.error('‚ùå Failed to initialize blocking system:', error);\n            }\n        });\n    }\n    openChatWithFriend(friendId, friendUsername) {\n        return __awaiter(this, void 0, void 0, function* () {\n            console.log(`üí¨ Opening chat with ${friendUsername} (ID: ${friendId})`);\n            // Ensure blocking system is loaded before checking permissions\n            try {\n                yield this.blockingManager.loadBlockedUsers();\n                console.log('‚úÖ Blocking system refreshed before opening chat');\n            }\n            catch (error) {\n                console.warn('‚ö†Ô∏è Could not refresh blocking system:', error);\n            }\n            // Si on ouvre la m√™me conversation, ne rien faire\n            if (this.currentChatUserId === friendId) {\n                console.log('‚ÑπÔ∏è Same chat already open');\n                this.switchToChatTab();\n                return;\n            }\n            // Configure WebSockets if needed\n            if (!this.chatWebSocketSetup) {\n                this.setupChatWebSocket();\n                this.chatWebSocketSetup = true;\n            }\n            // Clear interface immediately\n            const chatMessages = document.getElementById('chat-messages');\n            if (chatMessages) {\n                chatMessages.innerHTML = '';\n            }\n            // Update current chat variables\n            this.currentChatUserId = friendId;\n            this.currentChatUsername = friendUsername;\n            // Switch to chat tab\n            this.switchToChatTab();\n            // Check if chat is blocked AFTER setting up the interface\n            if (!this.blockingManager.canChat(friendId)) {\n                console.log(`üö´ Chat not allowed with ${friendUsername} - showing blocked interface`);\n                if (this.blockingManager.isBlocked(friendId)) {\n                    console.log(`üìõ User ${friendUsername} is blocked by me`);\n                    this.showBlockedInterface(friendId, friendUsername, true);\n                }\n                else if (this.blockingManager.isBlockedBy(friendId)) {\n                    console.log(`üö´ I am blocked by ${friendUsername}`);\n                    this.showBlockedInterface(friendId, friendUsername, false);\n                }\n                return;\n            }\n            // Setup chat interface for normal chat\n            this.setupChatInterface(friendId, friendUsername);\n            // Load chat history with small delay to avoid race conditions\n            setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n                if (this.currentChatUserId === friendId && this.blockingManager.canChat(friendId)) {\n                    yield this.loadChatHistory(friendId);\n                }\n            }), 50);\n            console.log(`‚úÖ Chat opened with ${friendUsername}`);\n        });\n    }\n    switchToChatTab() {\n        // Get the tab elements\n        const searchTabBtn = document.getElementById('search-tab-btn');\n        const chatTabBtn = document.getElementById('chat-tab-btn');\n        const searchTab = document.getElementById('search-tab');\n        const chatTab = document.getElementById('chat-tab');\n        if (!searchTabBtn || !chatTabBtn || !searchTab || !chatTab) {\n            console.error('Chat tab elements not found');\n            return;\n        }\n        // Update search tab button\n        searchTabBtn.classList.remove('bg-gradient-to-r', 'from-blue-500', 'to-indigo-600', 'text-white', 'shadow-lg');\n        searchTabBtn.classList.add('bg-dark-700', 'text-gray-400');\n        // Update chat tab button\n        chatTabBtn.classList.remove('bg-dark-700', 'text-gray-400');\n        chatTabBtn.classList.add('bg-gradient-to-r', 'from-blue-500', 'to-indigo-600', 'text-white', 'shadow-lg');\n        // Hide search tab and show chat tab\n        searchTab.classList.add('hidden');\n        chatTab.classList.remove('hidden');\n    }\n    setupChatInterface(friendId, friendUsername) {\n        // Get chat elements\n        const chatMessages = document.getElementById('chat-messages');\n        const noChatSelected = document.getElementById('no-chat-selected');\n        const chatInput = document.getElementById('chat-input');\n        if (!chatMessages || !chatInput) {\n            console.error('‚ùå Essential chat elements not found');\n            return;\n        }\n        // Hide \"no chat selected\" message if it exists\n        if (noChatSelected) {\n            noChatSelected.classList.add('hidden');\n        }\n        // Show chat input\n        chatInput.classList.remove('hidden');\n        console.log('üí¨ Chat interface ready');\n        // Clear previous messages from UI\n        chatMessages.innerHTML = '';\n        // Try to get friend's avatar from the friends list\n        let friendAvatarHtml = '<i class=\"fas fa-user text-white\"></i>';\n        const friendItem = document.querySelector(`.friend-item[data-id=\"${friendId}\"]`);\n        if (friendItem) {\n            const avatarElement = friendItem.querySelector('.friend-avatar img');\n            if (avatarElement) {\n                const avatarUrl = avatarElement.src;\n                friendAvatarHtml = createAvatarHTML({\n                    id: friendId,\n                    avatar_url: avatarUrl,\n                    username: friendUsername,\n                    has_avatar_data: true\n                }, 'medium');\n            }\n        }\n        // Add simplified header with friend info\n        const chatHeader = document.createElement('div');\n        chatHeader.className = 'sticky top-0 bg-dark-800 border-b border-dark-600 p-3 mb-2 z-10';\n        chatHeader.innerHTML = `\n            <div class=\"flex items-center justify-between\">\n                <div class=\"flex items-center\">\n                    <div class=\"w-10 h-10 bg-gradient-to-br from-blue-500 to-indigo-600 rounded-full mr-3 flex items-center justify-center overflow-hidden\">\n                        ${friendAvatarHtml}\n                    </div>\n                    <div>\n                        <h3 class=\"font-medium text-white\">${friendUsername}</h3>\n                    </div>\n                </div>\n                <div class=\"flex items-center space-x-2\">\n                    <button id=\"invite-game-chat\" class=\"px-3 py-1.5 text-white text-sm rounded-lg transition-all duration-200 \n                        bg-gradient-to-r from-emerald-500 to-teal-600 hover:from-emerald-600 hover:to-teal-700 \n                        flex items-center justify-center font-medium\">\n                        <i class=\"fas fa-gamepad mr-1.5\"></i> \n                        Jouer\n                    </button>\n                    <button id=\"block-user-chat\" class=\"px-3 py-1.5 text-gray-400 hover:text-red-400 text-sm rounded-lg transition-all duration-200 \n                        hover:bg-red-500/10 flex items-center justify-center\">\n                        <i class=\"fas fa-ban\"></i>\n                    </button>\n                </div>\n            </div>\n        `;\n        chatMessages.appendChild(chatHeader);\n        // Add event listener to close button\n        const closeButton = chatHeader.querySelector('#close-chat');\n        if (closeButton) {\n            closeButton.addEventListener('click', () => {\n                this.closeChatConversation();\n            });\n        }\n        // Add event listener to game invite button\n        const gameInviteButton = chatHeader.querySelector('#invite-game-chat');\n        if (gameInviteButton) {\n            gameInviteButton.addEventListener('click', () => {\n                this.sendGameInvitation(friendId, friendUsername);\n            });\n        }\n        // Add event listener to block button\n        const blockButton = chatHeader.querySelector('#block-user-chat');\n        if (blockButton) {\n            blockButton.addEventListener('click', () => {\n                this.blockUser(friendId, friendUsername);\n            });\n        }\n    }\n    closeChatConversation() {\n        this.currentChatUserId = null;\n        this.currentChatUsername = null;\n        const chatMessages = document.getElementById('chat-messages');\n        const noChatSelected = document.getElementById('no-chat-selected');\n        const chatInput = document.getElementById('chat-input');\n        if (chatMessages && noChatSelected && chatInput) {\n            chatMessages.innerHTML = '';\n            noChatSelected.classList.remove('hidden');\n            chatInput.classList.add('hidden');\n        }\n    }\n    sendChatMessage() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const messageInput = document.getElementById('message-input');\n            if (!messageInput) {\n                console.error('‚ùå Message input not found');\n                return;\n            }\n            const message = messageInput.value.trim();\n            if (!message || !this.currentChatUserId) {\n                return;\n            }\n            // Check if chat is allowed with current user\n            if (!this.blockingManager.canChat(this.currentChatUserId)) {\n                console.log('‚ùå Cannot send message - user blocked');\n                messageInput.value = '';\n                return;\n            }\n            console.log(`üì§ Sending: \"${message}\"`);\n            // Clear input immediately to provide immediate feedback\n            messageInput.value = '';\n            // Send message via WebSocket with improved connection handling\n            const websocketService = window.websocketService;\n            if (websocketService) {\n                try {\n                    // Ensure connection is established before sending\n                    const sent = yield websocketService.send('chat-message', {\n                        receiver_id: this.currentChatUserId,\n                        content: message,\n                        type: 'text'\n                    });\n                    if (!sent) {\n                        console.warn('‚ö†Ô∏è Failed to send message, restoring input');\n                        // Restore message in input if sending failed\n                        messageInput.value = message;\n                        // Show user feedback\n                        this.showTemporaryError('Message non envoy√© - probl√®me de connexion');\n                    }\n                }\n                catch (error) {\n                    console.error('‚ùå Error sending message:', error);\n                    // Restore message in input if sending failed\n                    messageInput.value = message;\n                    this.showTemporaryError('Erreur lors de l\\'envoi du message');\n                }\n            }\n            else {\n                console.warn('‚ö†Ô∏è WebSocket service not available');\n                // Restore message in input\n                messageInput.value = message;\n                this.showTemporaryError('Service de chat indisponible');\n            }\n        });\n    }\n    showTemporaryError(message) {\n        const chatMessages = document.getElementById('chat-messages');\n        if (!chatMessages)\n            return;\n        const errorDiv = document.createElement('div');\n        errorDiv.className = 'bg-red-500/20 border border-red-500/30 rounded-lg p-3 mx-4 mb-3 text-red-300 text-sm';\n        errorDiv.innerHTML = `<i class=\"fas fa-exclamation-triangle mr-2\"></i>${message}`;\n        chatMessages.appendChild(errorDiv);\n        chatMessages.scrollTop = chatMessages.scrollHeight;\n        // Remove error after 3 seconds\n        setTimeout(() => {\n            if (errorDiv.parentNode) {\n                errorDiv.parentNode.removeChild(errorDiv);\n            }\n        }, 3000);\n    }\n    // Alias pour compatibilit√©\n    sendMessage() {\n        this.sendChatMessage();\n    }\n    addMessageToChat(messageData, isSentByMe = false) {\n        const chatMessages = document.getElementById('chat-messages');\n        if (!chatMessages) {\n            console.error('‚ùå Chat messages container not found');\n            return;\n        }\n        // Simple check: only add if we're in a chat\n        if (!this.currentChatUserId) {\n            return;\n        }\n        console.log(`üí¨ Adding message: ${messageData.content} (sent by me: ${isSentByMe})`);\n        // Create simple message element\n        const messageDiv = document.createElement('div');\n        messageDiv.className = `flex mb-3 px-4 ${isSentByMe ? 'justify-end' : 'justify-start'}`;\n        const messageContent = document.createElement('div');\n        messageContent.className = `max-w-[70%] rounded-lg px-3 py-2 ${isSentByMe\n            ? 'bg-blue-600 text-white'\n            : 'bg-dark-700 text-gray-200 border border-dark-600'}`;\n        const messageText = document.createElement('div');\n        messageText.className = 'break-words';\n        messageText.textContent = messageData.content;\n        messageContent.appendChild(messageText);\n        messageDiv.appendChild(messageContent);\n        // Add to chat\n        chatMessages.appendChild(messageDiv);\n        // Scroll to bottom\n        chatMessages.scrollTop = chatMessages.scrollHeight;\n        // Simple cache management\n        if (!this.chatHistory.has(this.currentChatUserId)) {\n            this.chatHistory.set(this.currentChatUserId, []);\n        }\n        const history = this.chatHistory.get(this.currentChatUserId);\n        if (history && !history.find(msg => msg.id === messageData.id)) {\n            history.push(messageData);\n        }\n    }\n    addGameInviteToChat(inviteData, isSentByMe = false) {\n        const chatMessages = document.getElementById('chat-messages');\n        if (!chatMessages) {\n            console.error('‚ùå Chat messages container not found');\n            return;\n        }\n        // Create simple game invite message element\n        const messageDiv = document.createElement('div');\n        messageDiv.className = `flex mb-3 px-4 ${isSentByMe ? 'justify-end' : 'justify-start'}`;\n        const messageContent = document.createElement('div');\n        messageContent.className = `max-w-[70%] rounded-lg px-3 py-2 border ${isSentByMe\n            ? 'bg-emerald-600 text-white border-emerald-500'\n            : 'bg-purple-600/20 text-gray-200 border-purple-500'}`;\n        // Simple game invite content\n        const inviteText = document.createElement('div');\n        inviteText.className = 'flex items-center mb-2';\n        inviteText.innerHTML = `\n            <i class=\"fas fa-gamepad mr-2\"></i>\n            <span class=\"text-sm\">${isSentByMe ? 'Invitation envoy√©e' : 'Invitation √† jouer'}</span>\n        `;\n        messageContent.appendChild(inviteText);\n        // Add action buttons ONLY for received invitations\n        if (!isSentByMe) {\n            const actionsDiv = document.createElement('div');\n            actionsDiv.className = 'flex space-x-2';\n            actionsDiv.innerHTML = `\n                <button class=\"accept-game-invite px-2 py-1 text-xs bg-green-600 hover:bg-green-700 text-white rounded\">\n                    Accepter\n                </button>\n                <button class=\"reject-game-invite px-2 py-1 text-xs bg-gray-600 hover:bg-gray-700 text-white rounded\">\n                    Refuser\n                </button>\n            `;\n            messageContent.appendChild(actionsDiv);\n            // Add event listeners for buttons\n            const acceptBtn = actionsDiv.querySelector('.accept-game-invite');\n            const rejectBtn = actionsDiv.querySelector('.reject-game-invite');\n            if (acceptBtn) {\n                acceptBtn.addEventListener('click', () => {\n                    this.acceptGameInvitation(inviteData.id);\n                    actionsDiv.innerHTML = `<span class=\"text-green-300 text-xs\">‚úì Accept√©e</span>`;\n                });\n            }\n            if (rejectBtn) {\n                rejectBtn.addEventListener('click', () => {\n                    this.rejectGameInvitation(inviteData.id);\n                    actionsDiv.innerHTML = `<span class=\"text-gray-300 text-xs\">‚úó Refus√©e</span>`;\n                });\n            }\n        }\n        messageDiv.appendChild(messageContent);\n        // Add to chat\n        chatMessages.appendChild(messageDiv);\n        // Scroll to bottom\n        chatMessages.scrollTop = chatMessages.scrollHeight;\n        console.log(`üéÆ Game invitation added - Sent by me: ${isSentByMe}`);\n    }\n    loadChatHistory(friendId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Refresh blocking system before checking permissions\n            try {\n                yield this.blockingManager.loadBlockedUsers();\n                console.log('‚úÖ Blocking system refreshed before loading chat history');\n            }\n            catch (error) {\n                console.warn('‚ö†Ô∏è Could not refresh blocking system:', error);\n            }\n            // Verify chat is still allowed and we're in the right conversation\n            if (!this.blockingManager.canChat(friendId)) {\n                console.log('üö´ Chat history loading blocked - user restrictions');\n                // Show blocked interface instead of error\n                if (this.currentChatUserId === friendId) {\n                    this.showBlockedInterface(friendId, this.currentChatUsername || 'Utilisateur', this.blockingManager.isBlocked(friendId));\n                }\n                return;\n            }\n            // Verify we're still in the right conversation\n            if (this.currentChatUserId !== friendId) {\n                console.log('‚ö†Ô∏è Chat history loading cancelled - conversation changed');\n                return;\n            }\n            // Check if we have cached history\n            if (this.chatHistory.has(friendId)) {\n                console.log('üìö Loading from cache');\n                const messages = this.chatHistory.get(friendId);\n                const currentUserId = this.getCurrentUserId();\n                if (currentUserId) {\n                    messages.forEach((message) => {\n                        const isSentByMe = message.sender_id === currentUserId;\n                        if (message.type === 'game_invite') {\n                            this.addGameInviteToChat(message, isSentByMe);\n                        }\n                        else {\n                            this.addMessageToChat(message, isSentByMe);\n                        }\n                    });\n                    if (messages.length === 0) {\n                        this.showNoMessagesIndicator();\n                    }\n                }\n                return;\n            }\n            const chatMessages = document.getElementById('chat-messages');\n            if (!chatMessages) {\n                return;\n            }\n            // Show loading indicator\n            const loadingDiv = document.createElement('div');\n            loadingDiv.id = 'chat-loading';\n            loadingDiv.className = 'text-center text-gray-400 py-4';\n            loadingDiv.innerHTML = `<i class=\"fas fa-spinner fa-spin mr-2\"></i>Chargement...`;\n            chatMessages.appendChild(loadingDiv);\n            console.log('üì° Loading chat history from API');\n            try {\n                const response = yield _api__WEBPACK_IMPORTED_MODULE_0__.api.chat.getMessages(friendId);\n                // Check we're still in the right conversation and it's allowed\n                if (this.currentChatUserId !== friendId) {\n                    console.log('‚ö†Ô∏è Chat history response ignored - conversation changed');\n                    return;\n                }\n                if (!this.blockingManager.canChat(friendId)) {\n                    console.log('üö´ Chat history response ignored - user now blocked');\n                    // Remove loading and show blocked interface\n                    const loading = document.getElementById('chat-loading');\n                    if (loading)\n                        loading.remove();\n                    this.showBlockedInterface(friendId, this.currentChatUsername || 'Utilisateur', this.blockingManager.isBlocked(friendId));\n                    return;\n                }\n                // Remove loading indicator\n                const loading = document.getElementById('chat-loading');\n                if (loading)\n                    loading.remove();\n                if (response.success && response.data) {\n                    const messages = response.data;\n                    const currentUserId = this.getCurrentUserId();\n                    // Cache the messages\n                    this.chatHistory.set(friendId, messages);\n                    if (messages.length > 0 && currentUserId) {\n                        messages.forEach((message) => {\n                            const isSentByMe = message.sender_id === currentUserId;\n                            if (message.type === 'game_invite') {\n                                this.addGameInviteToChat(message, isSentByMe);\n                            }\n                            else {\n                                this.addMessageToChat(message, isSentByMe);\n                            }\n                        });\n                    }\n                    else {\n                        this.showNoMessagesIndicator();\n                    }\n                }\n                else {\n                    console.error('‚ùå Failed to load chat history:', response);\n                    // Check if it's a blocking-related error - check both message and error fields\n                    const errorMessage = response.error || response.message || '';\n                    const isBlockingError = (errorMessage.includes('blocked') ||\n                        errorMessage.includes('access') ||\n                        errorMessage.includes('forbidden') ||\n                        errorMessage.includes('Cannot access') ||\n                        response.status === 403);\n                    if (isBlockingError) {\n                        console.log('üö´ Chat access denied - refreshing blocking status and showing blocked interface');\n                        // Force refresh blocking status from server since there's a mismatch\n                        try {\n                            yield this.blockingManager.loadBlockedUsers();\n                            console.log('‚úÖ Blocking status refreshed after 403 error');\n                        }\n                        catch (error) {\n                            console.warn('‚ö†Ô∏è Could not refresh blocking status:', error);\n                        }\n                        // Determine who blocked whom based on the current blocking state\n                        const iBlockedThem = this.blockingManager.isBlocked(friendId);\n                        const theyBlockedMe = this.blockingManager.isBlockedBy(friendId);\n                        // Show appropriate blocked interface\n                        if (iBlockedThem) {\n                            console.log('üìõ I have blocked this user');\n                            this.showBlockedInterface(friendId, this.currentChatUsername || 'Cet utilisateur', true);\n                        }\n                        else if (theyBlockedMe) {\n                            console.log('üö´ This user has blocked me');\n                            this.showBlockedInterface(friendId, this.currentChatUsername || 'Cet utilisateur', false);\n                        }\n                        else {\n                            // If blocking status is still unclear, assume they blocked me (since we got 403)\n                            console.log('üö´ 403 error but unclear blocking status - assuming they blocked me');\n                            this.showBlockedInterface(friendId, this.currentChatUsername || 'Cet utilisateur', false);\n                        }\n                    }\n                    else {\n                        // Only show error for non-blocking related issues\n                        this.showChatError('Impossible de charger l\\'historique');\n                    }\n                }\n                // Scroll to bottom\n                chatMessages.scrollTop = chatMessages.scrollHeight;\n            }\n            catch (error) {\n                console.error('‚ùå Error loading chat history:', error);\n                // Check we're still in the right conversation\n                if (this.currentChatUserId !== friendId) {\n                    return;\n                }\n                // Remove loading indicator\n                const loading = document.getElementById('chat-loading');\n                if (loading)\n                    loading.remove();\n                // Check if it's a blocking-related error\n                const errorMessage = error.message || error.toString() || '';\n                const isBlockingError = (errorMessage.includes('blocked') ||\n                    errorMessage.includes('403') ||\n                    errorMessage.includes('access') ||\n                    errorMessage.includes('forbidden') ||\n                    errorMessage.includes('Cannot access') ||\n                    error.status === 403);\n                if (isBlockingError) {\n                    console.log('üö´ Chat access denied - refreshing blocking status and showing blocked interface');\n                    // Force refresh blocking status from server since there's a mismatch\n                    try {\n                        yield this.blockingManager.loadBlockedUsers();\n                        console.log('‚úÖ Blocking status refreshed after error');\n                    }\n                    catch (refreshError) {\n                        console.warn('‚ö†Ô∏è Could not refresh blocking status:', refreshError);\n                    }\n                    // Determine who blocked whom based on the current blocking state\n                    const iBlockedThem = this.blockingManager.isBlocked(friendId);\n                    const theyBlockedMe = this.blockingManager.isBlockedBy(friendId);\n                    // Show appropriate blocked interface\n                    if (iBlockedThem) {\n                        console.log('üìõ I have blocked this user');\n                        this.showBlockedInterface(friendId, this.currentChatUsername || 'Cet utilisateur', true);\n                    }\n                    else if (theyBlockedMe) {\n                        console.log('üö´ This user has blocked me');\n                        this.showBlockedInterface(friendId, this.currentChatUsername || 'Cet utilisateur', false);\n                    }\n                    else {\n                        // If blocking status is still unclear, assume they blocked me (since we got 403)\n                        console.log('üö´ 403 error but unclear blocking status - assuming they blocked me');\n                        this.showBlockedInterface(friendId, this.currentChatUsername || 'Cet utilisateur', false);\n                    }\n                }\n                else {\n                    // Only show error for non-blocking related issues\n                    this.showChatError('Erreur de connexion');\n                }\n            }\n        });\n    }\n    showNoMessagesIndicator() {\n        const chatMessages = document.getElementById('chat-messages');\n        if (!chatMessages)\n            return;\n        const noMessagesDiv = document.createElement('div');\n        noMessagesDiv.className = 'text-center text-gray-500 py-12 px-6';\n        noMessagesDiv.innerHTML = `\n            <div class=\"w-16 h-16 bg-gradient-to-br from-blue-500/20 to-indigo-600/20 rounded-full mx-auto mb-4 flex items-center justify-center border border-blue-500/30\">\n                <i class=\"fas fa-comments text-2xl text-blue-400\"></i>\n            </div>\n            <h3 class=\"text-lg font-medium text-gray-300 mb-2\">Aucun message encore</h3>\n            <p class=\"text-sm text-gray-500 mb-4\">Commencez la conversation avec ${this.currentChatUsername || 'votre ami'} !</p>\n            <div class=\"flex items-center justify-center space-x-4 text-xs text-gray-600\">\n                <div class=\"flex items-center\">\n                    <i class=\"fas fa-paper-plane mr-1\"></i>\n                    <span>Tapez votre message</span>\n                </div>\n                <div class=\"flex items-center\">\n                    <i class=\"fas fa-gamepad mr-1\"></i>\n                    <span>Ou lancez un d√©fi</span>\n                </div>\n            </div>\n        `;\n        chatMessages.appendChild(noMessagesDiv);\n    }\n    showChatError(message) {\n        const chatMessages = document.getElementById('chat-messages');\n        if (!chatMessages)\n            return;\n        const errorDiv = document.createElement('div');\n        errorDiv.className = 'flex flex-col items-center justify-center h-full py-16 px-6 text-center';\n        errorDiv.innerHTML = `\n            <div class=\"w-16 h-16 bg-red-500/20 rounded-full mb-6 flex items-center justify-center border border-red-500/30\">\n                <i class=\"fas fa-exclamation-triangle text-2xl text-red-400\"></i>\n            </div>\n            <h3 class=\"text-lg font-medium text-white mb-3\">Erreur lors du chargement</h3>\n            <p class=\"text-gray-400 text-sm mb-6\">${message}</p>\n            <button onclick=\"location.reload()\" class=\"px-4 py-2 bg-red-600 hover:bg-red-700 rounded-lg text-white text-sm font-medium transition-all duration-200\">\n                <i class=\"fas fa-redo mr-2\"></i>\n                R√©essayer\n            </button>\n        `;\n        chatMessages.appendChild(errorDiv);\n    }\n    setupChatWebSocket() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const websocketService = window.websocketService;\n            if (!websocketService) {\n                console.error('‚ùå WebSocket service not available');\n                return;\n            }\n            // Avoid multiple setups to prevent conflicts with friends system\n            if (this.chatWebSocketSetup) {\n                console.log('üîå Chat WebSocket handlers already setup, skipping');\n                return;\n            }\n            console.log('üîå Setting up chat WebSocket handlers');\n            // Ensure WebSocket is connected before setting up listeners\n            try {\n                if (!websocketService.isConnected()) {\n                    console.log('üîå WebSocket not connected, establishing connection...');\n                    yield websocketService.connect();\n                    console.log('‚úÖ WebSocket connection established for chat');\n                }\n            }\n            catch (error) {\n                console.error('‚ùå Failed to establish WebSocket connection for chat:', error);\n                // Continue with setup anyway, listeners will be attached when connection is established\n            }\n            // Listen for incoming chat messages - use unique handler names to avoid conflicts\n            websocketService.on('chat-message-received', (data) => {\n                console.log('üì® Received message from:', data.sender_id);\n                // Filter blocked users\n                if (!this.blockingManager.canChat(data.sender_id)) {\n                    console.log('üö´ Message filtered - user is blocked or has blocked you');\n                    return;\n                }\n                // Simple check: only show if it's from current chat user\n                if (this.currentChatUserId && data.sender_id === this.currentChatUserId) {\n                    this.addMessageToChat({\n                        content: data.content,\n                        type: data.type || 'text',\n                        sender_id: data.sender_id,\n                        receiver_id: this.getCurrentUserId(),\n                        id: data.id\n                    }, false);\n                }\n                // Always cache the message for the sender (if not blocked)\n                if (!this.chatHistory.has(data.sender_id)) {\n                    this.chatHistory.set(data.sender_id, []);\n                }\n                const senderHistory = this.chatHistory.get(data.sender_id);\n                if (senderHistory && !senderHistory.find(msg => msg.id === data.id)) {\n                    senderHistory.push(data);\n                }\n            });\n            // Listen for message confirmations\n            websocketService.on('chat-message-sent', (data) => {\n                console.log('‚úÖ Message sent confirmation');\n                // Check if message is blocked\n                if (!this.blockingManager.canChat(data.receiver_id)) {\n                    console.log('üö´ Message not sent - receiver is blocked or has blocked you');\n                    return;\n                }\n                // Check if we're currently chatting with this user\n                if (this.currentChatUserId === data.receiver_id) {\n                    this.addMessageToChat(data, true);\n                }\n                else {\n                    console.log('üì§ Message sent to different user, not displaying in current chat');\n                }\n            });\n            // Listen for game invitation confirmations\n            websocketService.on('game-invite-sent', (data) => {\n                console.log('‚úÖ Game invitation sent');\n            });\n            // Listen for incoming game invitations\n            websocketService.on('game-invite-received', (data) => {\n                console.log('üéÆ Game invitation received from:', data.sender_id);\n                // Filter blocked users for game invitations too\n                if (!this.blockingManager.canChat(data.sender_id)) {\n                    console.log('üö´ Game invitation filtered - user is blocked or has blocked you');\n                    return;\n                }\n                const invitationData = {\n                    id: data.id,\n                    sender_id: data.sender_id,\n                    receiver_id: this.getCurrentUserId(),\n                    type: 'game_invite',\n                    content: 'Invitation √† jouer'\n                };\n                // Add to current chat if it's from current user\n                if (this.currentChatUserId === data.sender_id) {\n                    this.addGameInviteToChat(invitationData, false);\n                }\n                // Always cache for later (if not blocked)\n                if (!this.chatHistory.has(data.sender_id)) {\n                    this.chatHistory.set(data.sender_id, []);\n                }\n                const senderHistory = this.chatHistory.get(data.sender_id);\n                if (senderHistory) {\n                    senderHistory.push(invitationData);\n                }\n            });\n            // Mark as setup to avoid conflicts\n            this.chatWebSocketSetup = true;\n            console.log('‚úÖ Chat WebSocket handlers setup complete');\n        });\n    }\n    getFriendNameById(friendId) {\n        // Try to find the friend name in the friends list\n        const friendItems = document.querySelectorAll('.friend-item');\n        for (const item of Array.from(friendItems)) {\n            if (item.getAttribute('data-id') === friendId.toString()) {\n                const usernameElement = item.querySelector('.friend-username');\n                return usernameElement ? usernameElement.textContent : null;\n            }\n        }\n        return null;\n    }\n    initializeChatEventListeners() {\n        console.log('üéß Initializing chat listeners');\n        // Wait for DOM to be ready\n        document.addEventListener('DOMContentLoaded', () => {\n            // Chat form submission\n            const chatForm = document.getElementById('chat-form');\n            if (chatForm) {\n                chatForm.addEventListener('submit', (e) => {\n                    e.preventDefault();\n                    this.sendChatMessage();\n                });\n            }\n            // Chat input enter key\n            const messageInput = document.getElementById('message-input');\n            if (messageInput) {\n                messageInput.addEventListener('keypress', (e) => {\n                    if (e.key === 'Enter' && !e.shiftKey) {\n                        e.preventDefault();\n                        this.sendChatMessage();\n                    }\n                });\n            }\n        });\n    }\n    // Public method to get current chat user (for external access)\n    getCurrentChatUserId() {\n        return this.currentChatUserId;\n    }\n    getCurrentChatUsername() {\n        return this.currentChatUsername;\n    }\n    // Get current user ID\n    getCurrentUserId() {\n        // Try to get from auth service first\n        const authService = window.authService;\n        if (authService === null || authService === void 0 ? void 0 : authService.getUserId) {\n            const userId = parseInt(authService.getUserId());\n            if (!isNaN(userId))\n                return userId;\n        }\n        const userIdStr = localStorage.getItem('user_id');\n        if (userIdStr) {\n            const userId = parseInt(userIdStr);\n            if (!isNaN(userId))\n                return userId;\n        }\n        return null;\n    }\n    // Method to clear chat history cache\n    clearChatHistory(friendId) {\n        if (friendId) {\n            this.chatHistory.delete(friendId);\n        }\n        else {\n            this.chatHistory.clear();\n        }\n    }\n    // Method to send game invitation\n    sendGameInvitation(friendId, friendUsername) {\n        console.log(`üéÆ Sending game invitation to ${friendUsername} (${friendId})`);\n        const websocketService = window.websocketService;\n        if (websocketService && websocketService.isConnected && websocketService.isConnected()) {\n            websocketService.send('game-invite', { friendId });\n            console.log(`üéÆ Game invitation sent to ${friendUsername}`);\n        }\n        else {\n            console.warn('‚ö†Ô∏è WebSocket not available for game invitation');\n        }\n    }\n    // Method to accept game invitation\n    acceptGameInvitation(inviteId) {\n        console.log(`üéÆ Accepting game invitation ${inviteId}`);\n        const websocketService = window.websocketService;\n        if (websocketService && websocketService.isConnected && websocketService.isConnected()) {\n            websocketService.send('game-invite-accept', { inviteId });\n            console.log('üéÆ Game invitation accepted, redirecting...');\n            // Redirect to game page\n            setTimeout(() => {\n                window.location.href = '/game.html';\n            }, 1000);\n        }\n        else {\n            console.warn('‚ö†Ô∏è WebSocket not available for game invitation');\n        }\n    }\n    // Method to reject game invitation\n    rejectGameInvitation(inviteId) {\n        console.log(`üéÆ Rejecting game invitation ${inviteId}`);\n        const websocketService = window.websocketService;\n        if (websocketService && websocketService.isConnected && websocketService.isConnected()) {\n            websocketService.send('game-invite-reject', { inviteId });\n            console.log('üéÆ Game invitation rejected');\n        }\n        else {\n            console.warn('‚ö†Ô∏è WebSocket not available for game invitation');\n        }\n    }\n    // Simplified block user method with immediate WebSocket feedback\n    blockUser(userId, username) {\n        return __awaiter(this, void 0, void 0, function* () {\n            console.log(`üö´ Blocking ${username}...`);\n            try {\n                const success = yield this.blockingManager.blockUser(userId);\n                if (success) {\n                    console.log(`‚úÖ User ${username} blocked successfully`);\n                    // If currently chatting with this user, show blocked interface\n                    if (this.currentChatUserId === userId) {\n                        this.showBlockedInterface(userId, username, true);\n                    }\n                    // NOUVEAU: Si on bloque quelqu'un depuis un autre endroit, fermer le chat s'il est ouvert\n                    if (this.currentChatUserId === userId) {\n                        console.log('üîÑ User blocked - updating chat interface');\n                        // Pas besoin de fermer compl√®tement, juste montrer l'interface bloqu√©e\n                        this.showBlockedInterface(userId, username, true);\n                    }\n                }\n                else {\n                    console.error('‚ùå Failed to block user');\n                }\n            }\n            catch (error) {\n                console.error('‚ùå Error blocking user:', error);\n            }\n        });\n    }\n    // FIXED: Simple and reliable blocked interface\n    showBlockedInterface(friendId, friendUsername, iBlockedThem) {\n        console.log(`üö´ Showing blocked interface for ${friendUsername} (I blocked them: ${iBlockedThem})`);\n        const chatMessages = document.getElementById('chat-messages');\n        const chatInput = document.getElementById('chat-input');\n        const noChatSelected = document.getElementById('no-chat-selected');\n        if (!chatMessages)\n            return;\n        // Hide chat input and no-chat-selected\n        if (chatInput)\n            chatInput.classList.add('hidden');\n        if (noChatSelected)\n            noChatSelected.classList.add('hidden');\n        // Clear messages and show blocked interface\n        chatMessages.innerHTML = '';\n        const blockedDiv = document.createElement('div');\n        blockedDiv.className = 'flex flex-col items-center justify-center h-full text-center p-8';\n        const message = iBlockedThem\n            ? `Vous avez bloqu√© ${friendUsername}`\n            : `${friendUsername} vous a bloqu√©`;\n        const description = iBlockedThem\n            ? 'Vous ne pouvez pas envoyer ou recevoir de messages.'\n            : 'Vous ne pouvez pas envoyer de messages √† cet utilisateur.';\n        blockedDiv.innerHTML = `\n            <div class=\"bg-dark-700 border border-dark-600 rounded-lg p-6 max-w-md\">\n                <div class=\"flex items-center justify-center w-16 h-16 bg-red-500/20 rounded-full mx-auto mb-4 border border-red-500/30\">\n                    <i class=\"fas fa-ban text-red-400 text-2xl\"></i>\n                </div>\n                <h3 class=\"text-lg font-semibold text-white mb-2\">${message}</h3>\n                <p class=\"text-gray-400 mb-4\">${description}</p>\n                ${iBlockedThem ? `\n                    <button id=\"unblock-user-btn\" \n                            class=\"bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg transition-colors duration-200 font-medium\">\n                        <i class=\"fas fa-unlock mr-2\"></i>D√©bloquer ${friendUsername}\n                    </button>\n                ` : `\n                    <div class=\"text-center\">\n                        <div class=\"inline-flex items-center px-4 py-2 bg-gray-700/50 rounded-lg text-gray-400 text-sm\">\n                            <i class=\"fas fa-info-circle mr-2\"></i>\n                            Aucune action disponible\n                        </div>\n                    </div>\n                `}\n            </div>\n        `;\n        chatMessages.appendChild(blockedDiv);\n        // Add unblock functionality if I blocked them\n        if (iBlockedThem) {\n            const unblockBtn = document.getElementById('unblock-user-btn');\n            if (unblockBtn) {\n                unblockBtn.addEventListener('click', () => __awaiter(this, void 0, void 0, function* () {\n                    var _a;\n                    console.log(`üîì Attempting to unblock ${friendUsername}`);\n                    // Disable button immediately to prevent double-clicks\n                    unblockBtn.disabled = true;\n                    unblockBtn.innerHTML = '<i class=\"fas fa-spinner fa-spin mr-2\"></i>D√©blocage...';\n                    try {\n                        // Unblock the user\n                        yield this.blockingManager.unblockUser(friendId);\n                        console.log(`‚úÖ Successfully unblocked ${friendUsername}`);\n                        // Force refresh the chat to ensure clean state\n                        this.forceRefreshChat(friendId, friendUsername);\n                    }\n                    catch (error) {\n                        console.error(`‚ùå Failed to unblock ${friendUsername}:`, error);\n                        // Re-enable button and show error\n                        unblockBtn.disabled = false;\n                        unblockBtn.innerHTML = '<i class=\"fas fa-unlock mr-2\"></i>D√©bloquer ' + friendUsername;\n                        // Show error message\n                        const errorDiv = document.createElement('div');\n                        errorDiv.className = 'mt-4 p-3 bg-red-500/20 border border-red-500/30 rounded-lg text-red-300 text-sm text-center';\n                        errorDiv.innerHTML = '<i class=\"fas fa-exclamation-triangle mr-2\"></i>Erreur lors du d√©blocage. Veuillez r√©essayer.';\n                        (_a = unblockBtn.parentElement) === null || _a === void 0 ? void 0 : _a.appendChild(errorDiv);\n                        // Remove error after 3 seconds\n                        setTimeout(() => {\n                            if (errorDiv.parentElement) {\n                                errorDiv.remove();\n                            }\n                        }, 3000);\n                    }\n                }));\n            }\n        }\n    }\n    // Public methods to access blocking system\n    isUserBlocked(userId) {\n        return this.blockingManager.isBlocked(userId);\n    }\n    isBlockedByUser(userId) {\n        return this.blockingManager.isBlockedBy(userId);\n    }\n    canChatWithUser(userId) {\n        return this.blockingManager.canChat(userId);\n    }\n    refreshBlockedUsers() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.blockingManager.loadBlockedUsers();\n        });\n    }\n    // NEW: Force refresh chat after unblock - clears everything and reloads properly\n    forceRefreshChat(friendId, friendUsername) {\n        console.log(`üîÑ Force refreshing chat with ${friendUsername} (ID: ${friendId})`);\n        // Clear current state completely\n        this.currentChatUserId = null;\n        this.currentChatUsername = null;\n        // Clear chat history cache for this user\n        this.chatHistory.delete(friendId);\n        // Clear the interface\n        const chatMessages = document.getElementById('chat-messages');\n        const chatInput = document.getElementById('chat-input');\n        const noChatSelected = document.getElementById('no-chat-selected');\n        if (chatMessages) {\n            chatMessages.innerHTML = '';\n        }\n        if (chatInput) {\n            chatInput.classList.add('hidden');\n        }\n        if (noChatSelected) {\n            noChatSelected.classList.remove('hidden');\n        }\n        // Wait a bit then reopen the chat properly\n        setTimeout(() => {\n            this.openChatWithFriend(friendId, friendUsername);\n        }, 100);\n    }\n}\n// Export a singleton instance\nconst chatManager = new ChatManager();\n// Expose globally for HTML access\nif (typeof window !== 'undefined') {\n    window.chatManager = chatManager;\n    window.ChatManager = ChatManager;\n}\n\n\n//# sourceURL=webpack://ft-transcendence-frontend/./src/ts/chat.ts?");

/***/ }),

/***/ "./src/ts/friends.ts":
/*!***************************!*\
  !*** ./src/ts/friends.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api */ \"./src/ts/api.ts\");\n/* harmony import */ var _websocket__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./websocket */ \"./src/ts/websocket.ts\");\n/* harmony import */ var _chat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chat */ \"./src/ts/chat.ts\");\n// This file will be compiled to JS and included in the HTML directly\n// Global services and types will be available\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n// Utility function to create avatar HTML with consistent styling\nfunction createAvatarHTML(user, size = 'medium') {\n    const sizeClasses = {\n        small: 'w-8 h-8 sm:w-10 sm:h-10',\n        medium: 'w-10 h-10 sm:w-12 sm:h-12',\n        large: 'w-16 h-16 sm:w-20 sm:h-20 md:w-24 md:h-24'\n    };\n    const iconSizes = {\n        small: 'text-sm sm:text-lg',\n        medium: 'text-lg sm:text-xl',\n        large: 'text-2xl sm:text-3xl md:text-4xl'\n    };\n    const sizeClass = sizeClasses[size];\n    const iconSize = iconSizes[size];\n    // Debug: Log user data for avatar creation\n    console.log('createAvatarHTML called with:', {\n        id: user.id,\n        username: user.username,\n        avatar_url: user.avatar_url,\n        has_avatar_data: user.has_avatar_data,\n        size: size\n    });\n    // Use getAvatarUrl to prioritize uploaded avatars over URLs\n    let avatarUrl = '';\n    if (user.id) {\n        avatarUrl = (0,_api__WEBPACK_IMPORTED_MODULE_0__.getAvatarUrl)({\n            id: user.id,\n            has_avatar_data: user.has_avatar_data,\n            avatar_url: user.avatar_url || undefined\n        });\n        console.log('Generated avatar URL:', avatarUrl);\n    }\n    else {\n        console.log('No user ID provided, using default icon');\n    }\n    if (avatarUrl && avatarUrl.trim()) {\n        return `<img src=\"${avatarUrl}\" alt=\"${user.username}\" class=\"w-full h-full object-cover rounded-full\" onerror=\"this.style.display='none'; this.nextElementSibling.style.display='flex';\">\n                <i class=\"fas fa-user text-white ${iconSize}\" style=\"display: none;\"></i>`;\n    }\n    else {\n        return `<i class=\"fas fa-user text-white ${iconSize}\"></i>`;\n    }\n}\ndocument.addEventListener('DOMContentLoaded', () => __awaiter(void 0, void 0, void 0, function* () {\n    console.log('Friends page loaded');\n    // Get services from global scope\n    const authService = window.authService;\n    console.log('Auth service available:', !!authService);\n    // Check if services are available\n    if (!_api__WEBPACK_IMPORTED_MODULE_0__.api || !_api__WEBPACK_IMPORTED_MODULE_0__.api.friendship) {\n        console.error('API or friendship module not available');\n        window.location.href = '/login.html';\n        return;\n    }\n    // Force auth service to refresh token state from storage\n    if (authService && authService.restoreSession) {\n        console.log('Friends: Restoring auth session');\n        authService.restoreSession();\n    }\n    // Check if user is authenticated properly using authService\n    const isAuthenticated = authService &&\n        authService.isAuthenticated &&\n        typeof authService.isAuthenticated === 'function' &&\n        authService.isAuthenticated();\n    console.log('Friends: User is authenticated:', isAuthenticated);\n    if (!isAuthenticated) {\n        console.log('Friends: User not authenticated, redirecting to login');\n        window.location.href = '/login.html';\n        return;\n    }\n    // V√©rifier explicitement que le token est disponible\n    const token = authService.getToken();\n    console.log('Friends: Auth token available:', !!token);\n    if (!token) {\n        console.log('Friends: No auth token available, redirecting to login');\n        authService.clearSession();\n        window.location.href = '/login.html';\n        return;\n    }\n    // Connect to WebSocket if available\n    if (_websocket__WEBPACK_IMPORTED_MODULE_1__.websocketService && _websocket__WEBPACK_IMPORTED_MODULE_1__.websocketService.connect) {\n        console.log('Connecting to WebSocket with auth token');\n        _websocket__WEBPACK_IMPORTED_MODULE_1__.websocketService.connect();\n        // V√©rifier la connexion apr√®s un court d√©lai\n        setTimeout(() => {\n            if (_websocket__WEBPACK_IMPORTED_MODULE_1__.websocketService.isConnected && _websocket__WEBPACK_IMPORTED_MODULE_1__.websocketService.isConnected()) {\n                console.log('WebSocket successfully connected!');\n            }\n            else {\n                console.log('WebSocket connection failed, retrying once more...');\n                _websocket__WEBPACK_IMPORTED_MODULE_1__.websocketService.connect();\n            }\n        }, 1000);\n    }\n    // DOM elements\n    const friendsContainer = document.getElementById('friends-container');\n    const noFriends = document.getElementById('no-friends');\n    const friendTemplate = document.getElementById('friend-template');\n    const friendRequestsContainer = document.getElementById('friend-requests-container');\n    const noFriendRequests = document.getElementById('no-friend-requests');\n    const friendRequestTemplate = document.getElementById('friend-request-template');\n    const searchUserForm = document.getElementById('search-user-form');\n    const searchUsername = document.getElementById('search-username');\n    const searchResultsContainer = document.getElementById('search-results-container');\n    const searchResults = document.getElementById('search-results');\n    const searchResultTemplate = document.getElementById('search-result-template');\n    const searchError = document.getElementById('search-error');\n    const searchErrorText = document.getElementById('search-error-text');\n    const friendsSearch = document.getElementById('friends-search');\n    // Register WebSocket event handlers if available\n    if (_websocket__WEBPACK_IMPORTED_MODULE_1__.websocketService && _websocket__WEBPACK_IMPORTED_MODULE_1__.websocketService.on) {\n        console.log('Setting up WebSocket event handlers for friends system');\n        // Check if friends WebSocket handlers are already setup to avoid conflicts\n        if (window.friendsWebSocketSetup) {\n            console.log('üîå Friends WebSocket handlers already setup, skipping');\n        }\n        else {\n            console.log('üîå Setting up friends WebSocket handlers');\n            // √âcouteur pour recevoir une demande d'ami\n            _websocket__WEBPACK_IMPORTED_MODULE_1__.websocketService.on('friend-request-received', (data) => {\n                var _a;\n                console.log('Received friend request via WebSocket:', data);\n                // Correction du format des donn√©es - chercher le nom d'utilisateur au bon endroit\n                const username = ((_a = data.from) === null || _a === void 0 ? void 0 : _a.username) || 'Quelqu\\'un';\n                // Recharger les demandes d'amiti√© en attente\n                loadFriendRequests();\n                // Afficher une notification\n                showNotification(`Nouvelle demande d'ami de ${username}`);\n                // Forcer le rechargement apr√®s un court d√©lai pour s'assurer que les donn√©es sont √† jour\n                setTimeout(() => {\n                    loadFriendRequests();\n                }, 500);\n            });\n            // √âcouteur pour les demandes envoy√©es\n            _websocket__WEBPACK_IMPORTED_MODULE_1__.websocketService.on('friend-request-sent', (data) => {\n                console.log('Friend request sent via WebSocket:', data);\n                // Trouver et mettre √† jour le bouton d'ajout dans l'interface si pr√©sent\n                const searchResultItem = document.querySelector(`.search-result-item[data-id=\"${data.friend_id}\"]`);\n                if (searchResultItem) {\n                    const sendButton = searchResultItem.querySelector('.add-friend-button');\n                    if (sendButton) {\n                        sendButton.innerHTML = '<i class=\"fas fa-check mr-2\"></i> Demande envoy√©e';\n                        sendButton.classList.remove('bg-blue-600', 'hover:bg-blue-700');\n                        sendButton.classList.add('bg-blue-600', 'cursor-not-allowed');\n                        sendButton.disabled = true;\n                    }\n                }\n                showNotification(`Demande d'ami envoy√©e √† ${data.friend_username || 'un utilisateur'}`);\n            });\n            // √âcouteur quand une demande d'ami est accept√©e\n            _websocket__WEBPACK_IMPORTED_MODULE_1__.websocketService.on('friend-request-accepted', (data) => {\n                console.log('Friend request accepted via WebSocket:', data);\n                // Recharger la liste d'amis\n                loadFriends();\n                // Afficher une notification\n                showNotification(`${data.friend_username || 'Quelqu\\'un'} a accept√© votre demande d'ami`);\n            });\n            // √âcouteur pour la r√©ponse (acceptation ou rejet) envoy√©e\n            _websocket__WEBPACK_IMPORTED_MODULE_1__.websocketService.on('friend-request-response-sent', (data) => {\n                console.log('Friend request response sent via WebSocket:', data);\n                const action = data.accepted ? 'accept√©e' : 'rejet√©e';\n                showNotification(`Demande d'ami ${action}`);\n                // Si c'est une acceptation, recharger la liste d'amis\n                if (data.accepted) {\n                    loadFriends();\n                }\n            });\n            // √âcouteur pour la suppression d'amiti√©\n            _websocket__WEBPACK_IMPORTED_MODULE_1__.websocketService.on('friend-removed', (data) => {\n                console.log('Friend removed via WebSocket:', data);\n                if (data.friend_id) {\n                    // Si on est notifi√© qu'un ami nous a retir√©\n                    showNotification(`Un utilisateur vous a retir√© de sa liste d'amis`, 'info');\n                    loadFriends(); // Rafra√Æchir la liste d'amis\n                }\n                else {\n                    // Confirmation de notre suppression\n                    showNotification(`Ami supprim√© avec succ√®s`, 'success');\n                }\n            });\n            // √âcouteur pour les changements de statut d'amis\n            _websocket__WEBPACK_IMPORTED_MODULE_1__.websocketService.on('friend-status-change', (data) => {\n                console.log('Friend status changed via WebSocket:', data);\n                updateFriendStatus(data.friend_id, data.status);\n            });\n            // Mark as setup to avoid conflicts\n            window.friendsWebSocketSetup = true;\n            console.log('‚úÖ Friends WebSocket handlers setup complete');\n        }\n    }\n    else {\n        console.warn('WebSocket service not available for event handling');\n    }\n    // Function to show notification - supprim√©\n    // Cette fonction a √©t√© supprim√©e pour simplifier l'interface\n    function showNotification(message, type = 'info') {\n        // Fonction d√©sactiv√©e - ne fait plus rien\n        console.log(`[Notification d√©sactiv√©e] ${type}: ${message}`);\n    }\n    // Function to update friend status in UI\n    function updateFriendStatus(userId, newStatus) {\n        console.log(`Updating friend status for user ${userId} to ${newStatus}`);\n        if (!userId) {\n            console.warn('No user ID provided for status update');\n            return;\n        }\n        const friendItem = document.querySelector(`.friend-item[data-id=\"${userId}\"]`);\n        if (!friendItem) {\n            console.warn(`Friend item with id ${userId} not found in the DOM`);\n            return;\n        }\n        const statusIndicator = friendItem.querySelector('.friend-status-indicator');\n        const status = friendItem.querySelector('.friend-status');\n        if (!statusIndicator || !status) {\n            console.warn('Status elements not found in friend item');\n            return;\n        }\n        // Remove existing status classes\n        statusIndicator.classList.remove('bg-blue-500', 'bg-gray-500');\n        // Set new status\n        if (newStatus === 'online') {\n            statusIndicator.classList.add('bg-blue-500');\n            status.textContent = 'En ligne';\n        }\n        else if (newStatus === 'in_game') {\n            statusIndicator.classList.add('bg-blue-500');\n            status.textContent = 'En jeu';\n        }\n        else {\n            statusIndicator.classList.add('bg-gray-500');\n            status.textContent = 'Hors ligne';\n        }\n    }\n    // Function to load friends list\n    function loadFriends() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const response = yield _api__WEBPACK_IMPORTED_MODULE_0__.api.friendship.getFriends();\n                if (response.success && response.data) {\n                    const friends = response.data;\n                    if (friends.length > 0) {\n                        // Hide no friends message\n                        noFriends.classList.add('hidden');\n                        friendsContainer.innerHTML = '';\n                        // Add each friend to the container\n                        friends.forEach((friend) => {\n                            addFriendToUI(friend);\n                        });\n                    }\n                    else {\n                        // Show no friends message\n                        noFriends.classList.remove('hidden');\n                        friendsContainer.innerHTML = '';\n                    }\n                }\n                else {\n                    console.error('Failed to load friends:', response.message);\n                }\n            }\n            catch (error) {\n                console.error('Error loading friends:', error);\n            }\n        });\n    }\n    // Function to add a friend to the UI\n    function addFriendToUI(friend) {\n        const friendElement = document.importNode(friendTemplate.content, true);\n        // Set friend details\n        const username = friendElement.querySelector('.friend-username');\n        const avatar = friendElement.querySelector('.friend-avatar');\n        const statusIndicator = friendElement.querySelector('.friend-status-indicator');\n        const status = friendElement.querySelector('.friend-status');\n        const chatButton = friendElement.querySelector('.chat-friend-button');\n        const removeButton = friendElement.querySelector('.remove-friend-button');\n        // Set username\n        username.textContent = friend.username;\n        // Make username and avatar clickable for profile viewing\n        username.classList.add('cursor-pointer', 'hover:text-blue-400', 'transition-colors', 'duration-200');\n        avatar.classList.add('cursor-pointer', 'hover:ring-2', 'hover:ring-blue-400', 'transition-all', 'duration-200');\n        // Add click event listeners for profile viewing\n        username.addEventListener('click', () => {\n            showUserProfile(friend.id, friend.username);\n        });\n        avatar.addEventListener('click', () => {\n            showUserProfile(friend.id, friend.username);\n        });\n        // Set avatar using consistent styling\n        avatar.innerHTML = createAvatarHTML(friend, 'medium');\n        // Set status indicator color and text\n        if (friend.status === 'online') {\n            statusIndicator.classList.add('bg-blue-500');\n            status.textContent = 'En ligne';\n        }\n        else if (friend.status === 'in_game') {\n            statusIndicator.classList.add('bg-blue-500');\n            status.textContent = 'En jeu';\n        }\n        else {\n            statusIndicator.classList.add('bg-gray-500');\n            status.textContent = 'Hors ligne';\n        }\n        // Add friend ID as data attribute\n        const friendItem = friendElement.querySelector('.friend-item');\n        friendItem.dataset.id = friend.id.toString();\n        // Ajouter un effet hover au bouton de suppression\n        removeButton.addEventListener('mouseenter', () => {\n            removeButton.innerHTML = '<i class=\"fas fa-user-times\"></i>';\n        });\n        removeButton.addEventListener('mouseleave', () => {\n            removeButton.innerHTML = '<i class=\"fas fa-times\"></i>';\n        });\n        // Add event listener to remove button\n        removeButton.addEventListener('click', () => __awaiter(this, void 0, void 0, function* () {\n            try {\n                // Afficher une confirmation avec un style moderne\n                const confirmDialog = document.createElement('div');\n                confirmDialog.className = 'fixed inset-0 flex items-center justify-center z-50';\n                confirmDialog.innerHTML = `\n                    <div class=\"absolute inset-0 bg-black bg-opacity-50 backdrop-blur-sm transition-opacity\"></div>\n                    <div class=\"bg-dark-800 rounded-xl shadow-2xl border border-dark-600 p-6 max-w-sm w-full mx-4 z-10 transform transition-all scale-95 opacity-0\">\n                        <div class=\"flex items-center justify-center mb-4 text-yellow-400\">\n                            <i class=\"fas fa-exclamation-triangle text-3xl\"></i>\n                        </div>\n                        <h3 class=\"text-xl font-medium text-center text-white mb-4\">Confirmer la suppression</h3>\n                        <p class=\"text-gray-300 mb-5 text-center\">√ätes-vous s√ªr de vouloir supprimer <span class=\"font-medium text-white\">${friend.username}</span> de votre liste d'amis ?</p>\n                        <div class=\"flex space-x-3 justify-center\">\n                            <button class=\"confirm-cancel-btn px-4 py-2 rounded-lg bg-dark-700 hover:bg-dark-600 text-white transition-colors\">\n                                Annuler\n                            </button>\n                            <button class=\"confirm-delete-btn px-4 py-2 rounded-lg bg-gradient-to-r from-red-500 to-red-600 hover:from-red-600 hover:to-red-700 text-white transition-colors\">\n                                Supprimer\n                            </button>\n                        </div>\n                    </div>\n                `;\n                document.body.appendChild(confirmDialog);\n                // Animer l'apparition\n                setTimeout(() => {\n                    const dialogContent = confirmDialog.querySelector('div:nth-child(2)');\n                    if (dialogContent) {\n                        dialogContent.classList.remove('scale-95', 'opacity-0');\n                        dialogContent.classList.add('scale-100', 'opacity-100');\n                    }\n                }, 10);\n                // Configurer les √©v√©nements\n                const cancelBtn = confirmDialog.querySelector('.confirm-cancel-btn');\n                const deleteBtn = confirmDialog.querySelector('.confirm-delete-btn');\n                return new Promise((resolve) => {\n                    if (cancelBtn) {\n                        cancelBtn.addEventListener('click', () => {\n                            // Animer la disparition\n                            const dialogContent = confirmDialog.querySelector('div:nth-child(2)');\n                            if (dialogContent) {\n                                dialogContent.classList.remove('scale-100', 'opacity-100');\n                                dialogContent.classList.add('scale-95', 'opacity-0');\n                            }\n                            setTimeout(() => {\n                                document.body.removeChild(confirmDialog);\n                                resolve(false);\n                            }, 200);\n                        });\n                    }\n                    if (deleteBtn) {\n                        deleteBtn.addEventListener('click', () => __awaiter(this, void 0, void 0, function* () {\n                            // Animer la disparition\n                            const dialogContent = confirmDialog.querySelector('div:nth-child(2)');\n                            if (dialogContent) {\n                                dialogContent.classList.remove('scale-100', 'opacity-100');\n                                dialogContent.classList.add('scale-95', 'opacity-0');\n                            }\n                            setTimeout(() => {\n                                document.body.removeChild(confirmDialog);\n                                resolve(true);\n                            }, 200);\n                            // D√©sactiver le bouton pour √©viter les clics multiples\n                            removeButton.disabled = true;\n                            removeButton.innerHTML = '<i class=\"fas fa-spinner fa-spin\"></i>';\n                            removeButton.classList.add('opacity-75');\n                            // Utiliser WebSocket si disponible\n                            const websocketService = window.websocketService;\n                            if (websocketService && websocketService.isConnected && websocketService.isConnected()) {\n                                console.log('Removing friend via WebSocket');\n                                websocketService.send('friend-remove', { friendId: friend.id });\n                                // NOUVEAU: Fermer le chat si c'est l'ami actuellement en discussion\n                                const chatManager = window.chatManager;\n                                if (chatManager && chatManager.getCurrentChatUserId() === friend.id) {\n                                    console.log('üîÑ Closing current chat conversation after friend removal');\n                                    chatManager.closeChatConversation();\n                                }\n                                // Animer la disparition de l'ami\n                                friendItem.style.transition = 'all 0.3s ease-out';\n                                friendItem.style.transform = 'translateX(10px)';\n                                friendItem.style.opacity = '0';\n                                setTimeout(() => {\n                                    // Remove friend from UI\n                                    friendItem.remove();\n                                    // Check if friends list is empty\n                                    if (friendsContainer.children.length === 0) {\n                                        noFriends.classList.remove('hidden');\n                                    }\n                                }, 300);\n                                // Afficher une notification\n                                showNotification(`${friend.username} a √©t√© retir√© de vos amis`, 'info');\n                            }\n                            else {\n                                // Fallback √† l'API REST\n                                console.log('WebSocket not available, using REST API');\n                                const response = yield _api__WEBPACK_IMPORTED_MODULE_0__.api.friendship.removeFriend(friend.id);\n                                if (response.success) {\n                                    // NOUVEAU: Fermer le chat si c'est l'ami actuellement en discussion\n                                    const chatManager = window.chatManager;\n                                    if (chatManager && chatManager.getCurrentChatUserId() === friend.id) {\n                                        console.log('üîÑ Closing current chat conversation after friend removal');\n                                        chatManager.closeChatConversation();\n                                    }\n                                    // Animer la disparition de l'ami\n                                    friendItem.style.transition = 'all 0.3s ease-out';\n                                    friendItem.style.transform = 'translateX(10px)';\n                                    friendItem.style.opacity = '0';\n                                    setTimeout(() => {\n                                        // Remove friend from UI\n                                        friendItem.remove();\n                                        // Check if friends list is empty\n                                        if (friendsContainer.children.length === 0) {\n                                            noFriends.classList.remove('hidden');\n                                        }\n                                    }, 300);\n                                    // Afficher une notification\n                                    showNotification(`${friend.username} a √©t√© retir√© de vos amis`, 'info');\n                                }\n                                else {\n                                    console.error('Failed to remove friend:', response.message);\n                                    showNotification(`Erreur: ${response.message}`, 'error');\n                                    // R√©activer le bouton en cas d'erreur\n                                    removeButton.disabled = false;\n                                    removeButton.innerHTML = '<i class=\"fas fa-times\"></i>';\n                                    removeButton.classList.remove('opacity-75');\n                                }\n                            }\n                        }));\n                    }\n                });\n            }\n            catch (error) {\n                console.error('Error removing friend:', error);\n                showNotification('Une erreur est survenue', 'error');\n            }\n        }));\n        // Add event listeners\n        chatButton.addEventListener('click', () => {\n            // NOUVEAU: Toujours permettre l'ouverture du chat (m√™me bloqu√©) pour voir l'interface\n            console.log(`üí¨ Opening chat with ${friend.username} (ID: ${friend.id}) - allowing blocked users`);\n            _chat__WEBPACK_IMPORTED_MODULE_2__.chatManager.openChatWithFriend(friend.id, friend.username);\n        });\n        // Add to container\n        friendsContainer.appendChild(friendElement);\n    }\n    // Function to show user profile in a modal\n    function showUserProfile(friendId, friendUsername) {\n        return __awaiter(this, void 0, void 0, function* () {\n            console.log(`üë§ Showing user profile for ${friendUsername} (ID: ${friendId})`);\n            // Remove existing profile modal if any\n            const existingModal = document.getElementById('user-profile-modal');\n            if (existingModal) {\n                existingModal.remove();\n            }\n            // Get friend data from the current friends list\n            const friendItem = document.querySelector(`.friend-item[data-id=\"${friendId}\"]`);\n            let friendStatus = 'Hors ligne';\n            if (friendItem) {\n                const statusElement = friendItem.querySelector('.friend-status');\n                if (statusElement) {\n                    friendStatus = statusElement.textContent || 'Hors ligne';\n                }\n            }\n            // Create modal overlay\n            const modalOverlay = document.createElement('div');\n            modalOverlay.id = 'user-profile-modal';\n            modalOverlay.className = 'fixed inset-0 bg-dark-900/80 backdrop-blur-sm flex items-center justify-center z-50 p-4';\n            // Create modal content\n            const modalContent = document.createElement('div');\n            modalContent.className = 'bg-dark-800 border border-dark-600 rounded-xl p-0 max-w-sm w-full shadow-2xl transform transition-all duration-300 scale-95 opacity-0';\n            // Show loading state initially\n            modalContent.innerHTML = `\n            <div class=\"relative\">\n                <!-- Header with close button -->\n                <div class=\"flex items-center justify-end p-4\">\n                    <button id=\"close-profile-modal\" class=\"text-gray-400 hover:text-white transition-colors p-1 rounded-lg hover:bg-dark-700\">\n                        <i class=\"fas fa-times text-lg\"></i>\n                    </button>\n                </div>\n                \n                <!-- Loading content -->\n                <div class=\"p-8 text-center\">\n                    <div class=\"w-16 h-16 bg-gradient-to-br from-blue-500/20 to-indigo-600/20 rounded-full mx-auto mb-4 flex items-center justify-center border border-blue-500/30\">\n                        <i class=\"fas fa-spinner fa-spin text-2xl text-blue-400\"></i>\n                    </div>\n                    <p class=\"text-gray-400\">Chargement du profil...</p>\n                </div>\n            </div>\n        `;\n            modalOverlay.appendChild(modalContent);\n            document.body.appendChild(modalOverlay);\n            // Animate modal appearance\n            setTimeout(() => {\n                modalContent.classList.remove('scale-95', 'opacity-0');\n                modalContent.classList.add('scale-100', 'opacity-100');\n            }, 10);\n            // Add close event listener for loading state\n            const closeButton = modalContent.querySelector('#close-profile-modal');\n            if (closeButton) {\n                closeButton.addEventListener('click', () => {\n                    modalContent.classList.remove('scale-100', 'opacity-100');\n                    modalContent.classList.add('scale-95', 'opacity-0');\n                    setTimeout(() => modalOverlay.remove(), 200);\n                });\n            }\n            // Close modal when clicking outside\n            modalOverlay.addEventListener('click', (e) => {\n                if (e.target === modalOverlay) {\n                    modalContent.classList.remove('scale-100', 'opacity-100');\n                    modalContent.classList.add('scale-95', 'opacity-0');\n                    setTimeout(() => modalOverlay.remove(), 200);\n                }\n            });\n            // Load real user profile data from API\n            try {\n                const authService = window.authService;\n                const token = authService === null || authService === void 0 ? void 0 : authService.getToken();\n                if (!token) {\n                    throw new Error('No authentication token available');\n                }\n                // Fetch user profile with real statistics\n                const response = yield fetch(`${_api__WEBPACK_IMPORTED_MODULE_0__.api.baseUrl}/users/${friendId}/profile`, {\n                    headers: {\n                        'Authorization': `Bearer ${token}`,\n                        'Content-Type': 'application/json'\n                    }\n                });\n                if (!response.ok) {\n                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n                }\n                const data = yield response.json();\n                if (!data.success) {\n                    throw new Error(data.message || 'Failed to load profile');\n                }\n                const profileData = data.data;\n                // Format join date\n                const joinDate = profileData.created_at\n                    ? new Date(profileData.created_at).toLocaleDateString('fr-FR', {\n                        year: 'numeric',\n                        month: 'long'\n                    })\n                    : 'Non disponible';\n                // Update modal content with real profile data\n                modalContent.innerHTML = `\n                <div class=\"relative\">\n                    <!-- Header with close button -->\n                    <div class=\"flex items-center justify-end p-4\">\n                        <button id=\"close-profile-modal\" class=\"text-gray-400 hover:text-white transition-colors p-1 rounded-lg hover:bg-dark-700\">\n                            <i class=\"fas fa-times text-lg\"></i>\n                        </button>\n                    </div>\n                    \n                    <!-- User Info Section -->\n                    <div class=\"px-6 pb-6\">\n                        <!-- Avatar and basic info -->\n                        <div class=\"text-center mb-6\">\n                            <div class=\"w-24 h-24 bg-gradient-to-br from-blue-500 to-indigo-600 rounded-full mx-auto mb-4 flex items-center justify-center shadow-lg border-4 border-dark-700 overflow-hidden\">\n                                ${createAvatarHTML(profileData, 'large')}\n                            </div>\n                            <h3 class=\"text-2xl font-bold text-white mb-2\">${profileData.username}</h3>\n                            <div class=\"flex items-center justify-center\">\n                                <span class=\"status-indicator ${friendStatus === 'En ligne' ? 'bg-green-400' : friendStatus === 'En jeu' ? 'bg-blue-400' : 'bg-gray-500'} w-3 h-3 rounded-full mr-2\"></span>\n                                <span class=\"text-sm ${friendStatus === 'En ligne' ? 'text-green-400' : friendStatus === 'En jeu' ? 'text-blue-400' : 'text-gray-400'}\">${friendStatus}</span>\n                            </div>\n                        </div>\n                        \n                        <!-- User Details -->\n                        <div class=\"space-y-4 mb-6\">\n                            <div class=\"bg-dark-700/50 rounded-lg p-4 border border-dark-600/50\">\n                                <div class=\"flex items-center mb-3\">\n                                    <h4 class=\"text-white font-medium flex items-center\">\n                                        <i class=\"fas fa-info-circle text-blue-400 mr-2\"></i>\n                                        Informations\n                                    </h4>\n                                </div>\n                                <div class=\"space-y-3\">\n                                    <div class=\"flex items-center justify-between\">\n                                        <span class=\"text-gray-400 text-sm flex items-center\">\n                                            <i class=\"fas fa-envelope text-gray-500 mr-2 w-4\"></i>\n                                            Email\n                                        </span>\n                                        <span class=\"text-white text-sm font-medium\">${profileData.email}</span>\n                                    </div>\n                                    <div class=\"flex items-center justify-between\">\n                                        <span class=\"text-gray-400 text-sm flex items-center\">\n                                            <i class=\"fas fa-calendar text-gray-500 mr-2 w-4\"></i>\n                                            Membre depuis\n                                        </span>\n                                        <span class=\"text-white text-sm font-medium\">${joinDate}</span>\n                                    </div>\n                                </div>\n                            </div>\n                            \n                            <!-- Stats Section -->\n                            <div class=\"bg-dark-700/50 rounded-lg p-4 border border-dark-600/50\">\n                                <div class=\"flex items-center mb-3\">\n                                    <h4 class=\"text-white font-medium flex items-center\">\n                                        <i class=\"fas fa-chart-bar text-purple-400 mr-2\"></i>\n                                        Statistiques de jeu\n                                    </h4>\n                                </div>\n                                <div class=\"grid grid-cols-2 gap-3\">\n                                    <div class=\"text-center p-3 bg-dark-800/50 rounded-lg border border-dark-600/30\">\n                                        <p class=\"text-2xl font-bold text-blue-400 mb-1\">${profileData.statistics.games_played}</p>\n                                        <p class=\"text-gray-400 text-xs\">Parties jou√©es</p>\n                                    </div>\n                                    <div class=\"text-center p-3 bg-dark-800/50 rounded-lg border border-dark-600/30\">\n                                        <p class=\"text-2xl font-bold text-green-400 mb-1\">${profileData.statistics.wins}</p>\n                                        <p class=\"text-gray-400 text-xs\">Victoires</p>\n                                    </div>\n                                    <div class=\"text-center p-3 bg-dark-800/50 rounded-lg border border-dark-600/30\">\n                                        <p class=\"text-2xl font-bold text-red-400 mb-1\">${profileData.statistics.losses}</p>\n                                        <p class=\"text-gray-400 text-xs\">D√©faites</p>\n                                    </div>\n                                    <div class=\"text-center p-3 bg-dark-800/50 rounded-lg border border-dark-600/30\">\n                                        <p class=\"text-2xl font-bold text-yellow-400 mb-1\">${profileData.statistics.win_rate}%</p>\n                                        <p class=\"text-gray-400 text-xs\">Taux de victoire</p>\n                                    </div>\n                                </div>\n                            </div>\n                        </div>\n                    </div>\n                </div>\n            `;\n                // Re-add close event listener\n                const newCloseButton = modalContent.querySelector('#close-profile-modal');\n                if (newCloseButton) {\n                    newCloseButton.addEventListener('click', () => {\n                        modalContent.classList.remove('scale-100', 'opacity-100');\n                        modalContent.classList.add('scale-95', 'opacity-0');\n                        setTimeout(() => modalOverlay.remove(), 200);\n                    });\n                }\n            }\n            catch (error) {\n                console.error('Error loading user profile:', error);\n                // Show error state\n                modalContent.innerHTML = `\n                <div class=\"relative\">\n                    <!-- Header with close button -->\n                    <div class=\"flex items-center justify-end p-4\">\n                        <button id=\"close-profile-modal\" class=\"text-gray-400 hover:text-white transition-colors p-1 rounded-lg hover:bg-dark-700\">\n                            <i class=\"fas fa-times text-lg\"></i>\n                        </button>\n                    </div>\n                    \n                    <!-- Error content -->\n                    <div class=\"p-8 text-center\">\n                        <div class=\"w-16 h-16 bg-red-500/20 rounded-full mx-auto mb-4 flex items-center justify-center border border-red-500/30\">\n                            <i class=\"fas fa-exclamation-triangle text-2xl text-red-400\"></i>\n                        </div>\n                        <h3 class=\"text-lg font-medium text-white mb-2\">Erreur de chargement</h3>\n                        <p class=\"text-gray-400 text-sm\">Impossible de r√©cup√©rer les informations de ${friendUsername}</p>\n                        <p class=\"text-gray-500 text-xs mt-2\">${error instanceof Error ? error.message : 'Erreur inconnue'}</p>\n                    </div>\n                </div>\n            `;\n                // Re-add close event listener\n                const errorCloseButton = modalContent.querySelector('#close-profile-modal');\n                if (errorCloseButton) {\n                    errorCloseButton.addEventListener('click', () => {\n                        modalContent.classList.remove('scale-100', 'opacity-100');\n                        modalContent.classList.add('scale-95', 'opacity-0');\n                        setTimeout(() => modalOverlay.remove(), 200);\n                    });\n                }\n            }\n        });\n    }\n    // Function to load friend requests\n    function loadFriendRequests() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                console.log('Loading friend requests...');\n                const response = yield _api__WEBPACK_IMPORTED_MODULE_0__.api.friendship.getPendingRequests();\n                console.log('Friend requests API response:', response);\n                if (response.success && response.data) {\n                    const requests = response.data;\n                    if (requests.length > 0) {\n                        // Hide no requests message\n                        noFriendRequests.classList.add('hidden');\n                        friendRequestsContainer.innerHTML = '';\n                        // Add each request to the container\n                        requests.forEach((request) => {\n                            console.log('Processing friend request:', request);\n                            addFriendRequestToUI(request);\n                        });\n                    }\n                    else {\n                        // Show no requests message\n                        noFriendRequests.classList.remove('hidden');\n                        friendRequestsContainer.innerHTML = '';\n                    }\n                }\n                else {\n                    console.error('Failed to load friend requests:', response.message);\n                }\n            }\n            catch (error) {\n                console.error('Error loading friend requests:', error);\n            }\n        });\n    }\n    // Function to add a friend request to the UI\n    function addFriendRequestToUI(request) {\n        console.log('Adding request to UI:', request);\n        // V√©rifier que l'objet user ou sender existe\n        if (!request.user && !request.sender) {\n            console.error('Friend request missing user data:', request);\n            return;\n        }\n        // Utiliser sender si user n'existe pas\n        const userData = request.user || request.sender;\n        // Debug: Log user data to see what avatar information is available\n        console.log('Friend request user data:', {\n            id: userData.id,\n            username: userData.username,\n            avatar_url: userData.avatar_url,\n            has_avatar_data: userData.has_avatar_data\n        });\n        const requestElement = document.importNode(friendRequestTemplate.content, true);\n        // Set request details\n        const username = requestElement.querySelector('.request-username');\n        const avatar = requestElement.querySelector('.request-avatar');\n        const acceptButton = requestElement.querySelector('.accept-request-button');\n        const rejectButton = requestElement.querySelector('.reject-request-button');\n        // Set username\n        username.textContent = userData.username;\n        // Set avatar using consistent styling - ensure all required properties are available\n        const avatarData = {\n            id: userData.id,\n            username: userData.username,\n            avatar_url: userData.avatar_url || null,\n            has_avatar_data: userData.has_avatar_data || false\n        };\n        console.log('Creating avatar with data:', avatarData);\n        avatar.innerHTML = createAvatarHTML(avatarData, 'medium');\n        // Add request ID as data attribute\n        const requestItem = requestElement.querySelector('.friend-request-item');\n        requestItem.dataset.id = request.id.toString();\n        // Store the user ID for accept/reject actions\n        const userId = userData.id;\n        requestItem.dataset.userId = userId.toString();\n        // Add event listener to accept button\n        acceptButton.addEventListener('click', () => __awaiter(this, void 0, void 0, function* () {\n            try {\n                // D√©sactiver les boutons pour √©viter les clics multiples\n                acceptButton.disabled = true;\n                rejectButton.disabled = true;\n                // Changer l'apparence du bouton pour indiquer le traitement\n                acceptButton.innerHTML = '<i class=\"fas fa-spinner fa-spin mr-1.5\"></i> Acceptation...';\n                acceptButton.classList.add('opacity-75');\n                rejectButton.classList.add('opacity-50');\n                // Utiliser WebSocket si disponible\n                const websocketService = window.websocketService;\n                if (websocketService && websocketService.isConnected && websocketService.isConnected()) {\n                    console.log('Accepting friend request via WebSocket');\n                    websocketService.send('friend-request-response', {\n                        friendId: userId,\n                        accept: true\n                    });\n                    // Animer la disparition de la demande\n                    requestItem.style.transition = 'all 0.3s ease-out';\n                    requestItem.style.transform = 'translateX(10px)';\n                    requestItem.style.opacity = '0';\n                    setTimeout(() => {\n                        // Remove request from UI\n                        requestItem.remove();\n                        // Check if requests list is empty\n                        if (friendRequestsContainer.children.length === 0) {\n                            noFriendRequests.classList.remove('hidden');\n                        }\n                    }, 300);\n                    // Reload friends list\n                    loadFriends();\n                    // Afficher une notification\n                    showNotification(`Vous √™tes maintenant ami avec ${userData.username}`, 'success');\n                }\n                else {\n                    // Fallback √† l'API REST\n                    console.log('WebSocket not available, using REST API');\n                    const response = yield _api__WEBPACK_IMPORTED_MODULE_0__.api.friendship.acceptFriendRequest(request.id);\n                    if (response.success) {\n                        // Animer la disparition de la demande\n                        requestItem.style.transition = 'all 0.3s ease-out';\n                        requestItem.style.transform = 'translateX(10px)';\n                        requestItem.style.opacity = '0';\n                        setTimeout(() => {\n                            // Remove request from UI\n                            requestItem.remove();\n                            // Check if requests list is empty\n                            if (friendRequestsContainer.children.length === 0) {\n                                noFriendRequests.classList.remove('hidden');\n                            }\n                        }, 300);\n                        // Reload friends list\n                        loadFriends();\n                        // Afficher une notification\n                        showNotification(`Vous √™tes maintenant ami avec ${userData.username}`, 'success');\n                    }\n                    else {\n                        console.error('Failed to accept friend request:', response.message);\n                        showNotification(`Erreur: ${response.message}`, 'error');\n                        // R√©activer les boutons en cas d'erreur\n                        acceptButton.disabled = false;\n                        rejectButton.disabled = false;\n                        acceptButton.innerHTML = '<i class=\"fas fa-check mr-1.5\"></i> Accepter';\n                        acceptButton.classList.remove('opacity-75');\n                        rejectButton.classList.remove('opacity-50');\n                    }\n                }\n            }\n            catch (error) {\n                console.error('Error accepting friend request:', error);\n                showNotification('Une erreur est survenue', 'error');\n                // R√©activer les boutons en cas d'erreur\n                acceptButton.disabled = false;\n                rejectButton.disabled = false;\n                acceptButton.innerHTML = '<i class=\"fas fa-check mr-1.5\"></i> Accepter';\n                acceptButton.classList.remove('opacity-75');\n                rejectButton.classList.remove('opacity-50');\n            }\n        }));\n        // Add event listener to reject button with the same pattern\n        rejectButton.addEventListener('click', () => __awaiter(this, void 0, void 0, function* () {\n            try {\n                // D√©sactiver les boutons pour √©viter les clics multiples\n                rejectButton.disabled = true;\n                acceptButton.disabled = true;\n                // Changer l'apparence du bouton pour indiquer le traitement\n                rejectButton.innerHTML = '<i class=\"fas fa-spinner fa-spin mr-1.5\"></i> Refus...';\n                rejectButton.classList.add('opacity-75');\n                acceptButton.classList.add('opacity-50');\n                // Utiliser WebSocket si disponible\n                const websocketService = window.websocketService;\n                if (websocketService && websocketService.isConnected && websocketService.isConnected()) {\n                    console.log('Rejecting friend request via WebSocket');\n                    websocketService.send('friend-request-response', {\n                        friendId: userId,\n                        accept: false\n                    });\n                    // Animer la disparition de la demande\n                    requestItem.style.transition = 'all 0.3s ease-out';\n                    requestItem.style.transform = 'translateX(10px)';\n                    requestItem.style.opacity = '0';\n                    setTimeout(() => {\n                        // Remove request from UI\n                        requestItem.remove();\n                        // Check if requests list is empty\n                        if (friendRequestsContainer.children.length === 0) {\n                            noFriendRequests.classList.remove('hidden');\n                        }\n                    }, 300);\n                }\n                else {\n                    // Fallback √† l'API REST\n                    console.log('WebSocket not available, using REST API');\n                    const response = yield _api__WEBPACK_IMPORTED_MODULE_0__.api.friendship.rejectFriendRequest(request.id);\n                    if (response.success) {\n                        // Animer la disparition de la demande\n                        requestItem.style.transition = 'all 0.3s ease-out';\n                        requestItem.style.transform = 'translateX(10px)';\n                        requestItem.style.opacity = '0';\n                        setTimeout(() => {\n                            // Remove request from UI\n                            requestItem.remove();\n                            // Check if requests list is empty\n                            if (friendRequestsContainer.children.length === 0) {\n                                noFriendRequests.classList.remove('hidden');\n                            }\n                        }, 300);\n                    }\n                    else {\n                        console.error('Failed to reject friend request:', response.message);\n                        showNotification(`Erreur: ${response.message}`, 'error');\n                        // R√©activer les boutons en cas d'erreur\n                        rejectButton.disabled = false;\n                        acceptButton.disabled = false;\n                        rejectButton.innerHTML = '<i class=\"fas fa-times mr-1.5\"></i> Refuser';\n                        rejectButton.classList.remove('opacity-75');\n                        acceptButton.classList.remove('opacity-50');\n                    }\n                }\n            }\n            catch (error) {\n                console.error('Error rejecting friend request:', error);\n                showNotification('Une erreur est survenue', 'error');\n                // R√©activer les boutons en cas d'erreur\n                rejectButton.disabled = false;\n                acceptButton.disabled = false;\n                rejectButton.innerHTML = '<i class=\"fas fa-times mr-1.5\"></i> Refuser';\n                rejectButton.classList.remove('opacity-75');\n                acceptButton.classList.remove('opacity-50');\n            }\n        }));\n        // Add to container\n        friendRequestsContainer.appendChild(requestElement);\n    }\n    // Function to search for users\n    function searchUsers(username) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                searchResults.innerHTML = '';\n                if (!username.trim()) {\n                    searchResultsContainer.classList.add('hidden');\n                    return;\n                }\n                // Show loading state\n                searchResults.innerHTML = `\n                <div class=\"text-center py-4\">\n                    <svg class=\"animate-spin h-8 w-8 mx-auto text-blue-600\" xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\">\n                        <circle class=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" stroke-width=\"4\"></circle>\n                        <path class=\"opacity-75\" fill=\"currentColor\" d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"></path>\n                    </svg>\n                    <p class=\"mt-2 text-gray-400\">Recherche en cours...</p>\n                </div>\n            `;\n                searchResultsContainer.classList.remove('hidden');\n                // First check if the exact username exists\n                const checkResponse = yield _api__WEBPACK_IMPORTED_MODULE_0__.api.user.checkUsername(username);\n                // If exact username exists, highlight it\n                if (checkResponse.success && checkResponse.exists && checkResponse.user) {\n                    const exactUser = checkResponse.user;\n                    searchResults.innerHTML = '';\n                    // Add the exact match with special highlighting\n                    const resultElement = document.createElement('div');\n                    resultElement.className = 'search-result-item exact-match p-3 mb-3 bg-blue-900/20 border border-blue-600/30 rounded-lg flex items-center justify-between cursor-pointer transition duration-200 hover:bg-dark-600';\n                    resultElement.dataset.id = exactUser.id.toString();\n                    resultElement.innerHTML = `\n                    <div class=\"flex items-center\">\n                        <div class=\"result-avatar w-12 h-12 bg-gradient-to-br from-blue-500 to-indigo-600 rounded-full mr-4 flex items-center justify-center overflow-hidden border border-dark-500\">\n                            ${exactUser.avatar_url ? createAvatarHTML(exactUser, 'medium') : '<i class=\"fas fa-user text-white text-xl\"></i>'}\n                        </div>\n                        <div>\n                            <p class=\"font-medium text-white\">${exactUser.username} <i class=\"fas fa-check-circle text-purple-400 ml-1\"></i></p>\n                            <div class=\"flex items-center text-sm\">\n                                <span class=\"status-indicator ${exactUser.status === 'online' ? 'bg-blue-400' : 'bg-gray-500'} w-2 h-2 rounded-full mr-2\"></span>\n                                <span class=\"text-gray-400\">${exactUser.status === 'online' ? 'En ligne' : 'Hors ligne'}</span>\n                            </div>\n                        </div>\n                    </div>\n                    <button class=\"add-friend-button px-3 py-2 rounded-lg bg-blue-600 hover:bg-blue-700 text-white text-sm font-medium transition duration-150 ease-in-out flex items-center\">\n                        <i class=\"fas fa-user-plus mr-2\"></i>\n                        Ajouter\n                    </button>\n                `;\n                    // Add event listener for the add button\n                    const addButton = resultElement.querySelector('.add-friend-button');\n                    addButton.addEventListener('click', () => __awaiter(this, void 0, void 0, function* () {\n                        try {\n                            // Disable button to prevent multiple clicks\n                            addButton.disabled = true;\n                            addButton.classList.add('opacity-50');\n                            addButton.innerHTML = '<span class=\"spinner inline-block w-4 h-4 border-2 border-t-transparent border-white rounded-full animate-spin mr-2\"></span> Envoi...';\n                            // Send friend request via WebSocket or API\n                            if (_websocket__WEBPACK_IMPORTED_MODULE_1__.websocketService && _websocket__WEBPACK_IMPORTED_MODULE_1__.websocketService.isConnected && _websocket__WEBPACK_IMPORTED_MODULE_1__.websocketService.isConnected()) {\n                                _websocket__WEBPACK_IMPORTED_MODULE_1__.websocketService.send('friend-request', { friendId: exactUser.id });\n                            }\n                            else {\n                                yield _api__WEBPACK_IMPORTED_MODULE_0__.api.friendship.sendFriendRequest(exactUser.id);\n                            }\n                            // Update UI to show success\n                            resultElement.innerHTML = `\n                            <div class=\"flex items-center justify-between w-full\">\n                                <div class=\"flex items-center\">\n                                    <div class=\"result-avatar w-12 h-12 bg-dark-600 rounded-full mr-4 flex items-center justify-center overflow-hidden border border-dark-500\">\n                                        ${exactUser.avatar_url ? createAvatarHTML(exactUser, 'medium') : '<i class=\"fas fa-user text-white text-xl\"></i>'}\n                                    </div>\n                                    <div>\n                                        <p class=\"font-medium text-white\">${exactUser.username}</p>\n                                        <div class=\"flex items-center text-sm\">\n                                            <span class=\"text-purple-400\">Demande d'ami envoy√©e</span>\n                                        </div>\n                                    </div>\n                                </div>\n                                <div class=\"animate-pulse\">\n                                    <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"h-6 w-6 text-purple-400\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n                                        <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z\" />\n                                    </svg>\n                                </div>\n                            </div>\n                        `;\n                            // Afficher une notification\n                            showNotification(`Demande d'ami envoy√©e √† ${exactUser.username}`, 'success');\n                            // Hide search results after a delay\n                            setTimeout(() => {\n                                searchResultsContainer.classList.add('hidden');\n                                searchUserForm.reset();\n                            }, 2000);\n                        }\n                        catch (error) {\n                            console.error('Error sending friend request:', error);\n                            addButton.disabled = false;\n                            addButton.classList.remove('opacity-50');\n                            addButton.innerHTML = '<i class=\"fas fa-user-plus mr-2\"></i> Ajouter';\n                            showNotification('Erreur lors de l\\'envoi de la demande d\\'ami', 'error');\n                        }\n                    }));\n                    searchResults.appendChild(resultElement);\n                    // Also search for similar users for convenience\n                    const response = yield _api__WEBPACK_IMPORTED_MODULE_0__.api.user.searchUsers(username);\n                    if (response.success && response.data && response.data.length > 1) {\n                        // Add a separator\n                        const separator = document.createElement('div');\n                        separator.className = 'my-3 text-gray-500 text-sm font-medium px-2 border-t border-dark-600 pt-3';\n                        separator.textContent = 'Autres utilisateurs similaires';\n                        searchResults.appendChild(separator);\n                        // Add other similar users\n                        response.data.slice(1).forEach((user) => {\n                            addSearchResultToUI(user);\n                        });\n                    }\n                }\n                else {\n                    // Standard search\n                    const response = yield _api__WEBPACK_IMPORTED_MODULE_0__.api.user.searchUsers(username);\n                    if (response.success) {\n                        const data = response.data;\n                        searchResults.innerHTML = '';\n                        if (data.length > 0) {\n                            data.forEach((user) => {\n                                addSearchResultToUI(user);\n                            });\n                        }\n                        else {\n                            searchResults.innerHTML = `\n                            <div class=\"text-center py-6 bg-dark-700/40 rounded-lg\">\n                                <i class=\"fas fa-search text-gray-500 text-3xl mb-2\"></i>\n                                <p class=\"text-gray-400 mt-2\">Aucun utilisateur trouv√© pour \"${username}\"</p>\n                            </div>\n                        `;\n                        }\n                    }\n                    else {\n                        throw new Error(response.message || 'Failed to search users');\n                    }\n                }\n            }\n            catch (error) {\n                console.error('Error searching users:', error);\n                searchResults.innerHTML = '';\n                searchError.classList.remove('hidden');\n                searchErrorText.textContent = 'Erreur lors de la recherche. Veuillez r√©essayer.';\n                // Hide error after 3 seconds\n                setTimeout(() => {\n                    searchError.classList.add('hidden');\n                }, 3000);\n            }\n        });\n    }\n    // Function to add a search result to the UI\n    function addSearchResultToUI(user) {\n        const resultElement = document.importNode(searchResultTemplate.content, true);\n        // Set user details\n        const username = resultElement.querySelector('.result-username');\n        const avatar = resultElement.querySelector('.result-avatar');\n        const statusDiv = resultElement.querySelector('.result-status');\n        const sendButton = resultElement.querySelector('.add-friend-button');\n        // Set username\n        username.textContent = user.username;\n        // Set status\n        if (user.status) {\n            const isOnline = user.status === 'online';\n            statusDiv.innerHTML = `\n                <span class=\"status-indicator ${isOnline ? 'bg-blue-400' : 'bg-gray-500'} w-2 h-2 rounded-full mr-2\"></span>\n                <span>${isOnline ? 'En ligne' : 'Hors ligne'}</span>\n            `;\n        }\n        // Set avatar using consistent styling\n        avatar.innerHTML = createAvatarHTML(user, 'medium');\n        // Add user ID as data attribute\n        const resultItem = resultElement.querySelector('.search-result-item');\n        resultItem.dataset.id = user.id.toString();\n        // Add event listener to send button\n        sendButton.addEventListener('click', () => __awaiter(this, void 0, void 0, function* () {\n            try {\n                // Check if user ID is available\n                if (!user.id) {\n                    console.error('User ID not found');\n                    return;\n                }\n                // D√©sactiver le bouton pour √©viter les clics multiples\n                sendButton.disabled = true;\n                sendButton.classList.add('opacity-50');\n                sendButton.innerHTML = '<span class=\"spinner inline-block w-4 h-4 border-2 border-t-transparent border-white rounded-full animate-spin mr-2\"></span> Envoi...';\n                // Utiliser WebSocket si disponible\n                const websocketService = window.websocketService;\n                if (websocketService && websocketService.isConnected && websocketService.isConnected()) {\n                    console.log('Sending friend request via WebSocket');\n                    websocketService.send('friend-request', { friendId: user.id });\n                    // Remplacer le r√©sultat de recherche par un message de confirmation\n                    resultItem.innerHTML = `\n                        <div class=\"flex items-center justify-between w-full\">\n                            <div class=\"flex items-center\">\n                                <div class=\"result-avatar w-12 h-12 bg-gradient-to-br from-blue-500 to-indigo-600 rounded-full mr-4 flex items-center justify-center overflow-hidden border border-dark-500\">\n                                    ${avatar.innerHTML}\n                                </div>\n                                <div>\n                                    <p class=\"font-medium text-white\">${user.username}</p>\n                                    <div class=\"flex items-center text-sm\">\n                                        <span class=\"text-purple-400\">Demande d'ami envoy√©e</span>\n                                    </div>\n                                </div>\n                            </div>\n                            <div class=\"animate-pulse\">\n                                <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"h-6 w-6 text-purple-400\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n                                    <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z\" />\n                                </svg>\n                            </div>\n                        </div>\n                    `;\n                    // Afficher une notification\n                    showNotification(`Demande d'ami envoy√©e √† ${user.username}`, 'success');\n                    // Apr√®s 3 secondes, cacher les r√©sultats de recherche et r√©initialiser le formulaire\n                    setTimeout(() => {\n                        searchResultsContainer.classList.add('hidden');\n                        searchUserForm.reset();\n                        // R√©initialisez le r√©sultat apr√®s quelques secondes\n                        searchResults.innerHTML = '';\n                    }, 2000);\n                }\n                else {\n                    // Fallback √† l'API REST\n                    console.log('WebSocket not available, using REST API');\n                    const response = yield _api__WEBPACK_IMPORTED_MODULE_0__.api.friendship.sendFriendRequest(user.id);\n                    if (response.success) {\n                        // Remplacer le r√©sultat de recherche par un message de confirmation\n                        resultItem.innerHTML = `\n                            <div class=\"flex items-center justify-between w-full\">\n                                <div class=\"flex items-center\">\n                                    <div class=\"result-avatar w-12 h-12 bg-gradient-to-br from-blue-500 to-indigo-600 rounded-full mr-4 flex items-center justify-center overflow-hidden border border-dark-500\">\n                                        ${avatar.innerHTML}\n                                    </div>\n                                    <div>\n                                        <p class=\"font-medium text-white\">${user.username}</p>\n                                        <div class=\"flex items-center text-sm\">\n                                            <span class=\"text-purple-400\">Demande d'ami envoy√©e</span>\n                                        </div>\n                                    </div>\n                                </div>\n                                <div class=\"animate-pulse\">\n                                    <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"h-6 w-6 text-purple-400\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n                                        <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z\" />\n                                    </svg>\n                                </div>\n                            </div>\n                        `;\n                        // Afficher une notification\n                        showNotification(`Demande d'ami envoy√©e √† ${user.username}`, 'success');\n                        // Apr√®s 3 secondes, cacher les r√©sultats de recherche et r√©initialiser le formulaire\n                        setTimeout(() => {\n                            searchResultsContainer.classList.add('hidden');\n                            searchUserForm.reset();\n                            // R√©initialisez le r√©sultat apr√®s quelques secondes\n                            searchResults.innerHTML = '';\n                        }, 2000);\n                    }\n                    else {\n                        console.error('Failed to send friend request:', response.message);\n                        showNotification(`Erreur: ${response.message}`, 'error');\n                        // R√©activer le bouton en cas d'erreur\n                        sendButton.disabled = false;\n                        sendButton.classList.remove('opacity-50');\n                        sendButton.innerHTML = '<i class=\"fas fa-user-plus mr-1.5\"></i> Ajouter';\n                    }\n                }\n            }\n            catch (error) {\n                console.error('Error sending friend request:', error);\n                showNotification('Une erreur est survenue', 'error');\n                // R√©activer le bouton en cas d'erreur\n                sendButton.disabled = false;\n                sendButton.classList.remove('opacity-50');\n                sendButton.innerHTML = '<i class=\"fas fa-user-plus mr-1.5\"></i> Ajouter';\n            }\n        }));\n        searchResults.appendChild(resultElement);\n    }\n    // Event listener for search form submission\n    if (searchUserForm) {\n        searchUserForm.addEventListener('submit', (e) => {\n            e.preventDefault();\n            const usernameValue = searchUsername.value.trim();\n            if (usernameValue) {\n                // First check if exact username exists\n                _api__WEBPACK_IMPORTED_MODULE_0__.api.user.checkUsername(usernameValue)\n                    .then(response => {\n                    if (response.success && response.exists && response.user) {\n                        // If exact username exists, send friend request directly\n                        if (_websocket__WEBPACK_IMPORTED_MODULE_1__.websocketService && _websocket__WEBPACK_IMPORTED_MODULE_1__.websocketService.isConnected && _websocket__WEBPACK_IMPORTED_MODULE_1__.websocketService.isConnected()) {\n                            _websocket__WEBPACK_IMPORTED_MODULE_1__.websocketService.send('friend-request', { friendId: response.user.id });\n                            showNotification(`Demande d'ami envoy√©e √† ${response.user.username}`, 'success');\n                            searchUserForm.reset();\n                            searchResultsContainer.classList.add('hidden');\n                        }\n                        else {\n                            _api__WEBPACK_IMPORTED_MODULE_0__.api.friendship.sendFriendRequest(response.user.id)\n                                .then(res => {\n                                if (res.success) {\n                                    showNotification(`Demande d'ami envoy√©e √† ${response.user.username}`, 'success');\n                                    searchUserForm.reset();\n                                    searchResultsContainer.classList.add('hidden');\n                                }\n                                else {\n                                    showNotification(res.message || 'Erreur lors de l\\'envoi de la demande', 'error');\n                                }\n                            })\n                                .catch(err => {\n                                console.error('Error sending friend request:', err);\n                                showNotification('Erreur lors de l\\'envoi de la demande', 'error');\n                            });\n                        }\n                    }\n                    else {\n                        // If no exact match, show search results\n                        searchUsers(usernameValue);\n                    }\n                })\n                    .catch(err => {\n                    console.error('Error checking username:', err);\n                    // Fall back to regular search\n                    searchUsers(usernameValue);\n                });\n            }\n        });\n        // Add keyup listener for real-time search\n        if (searchUsername) {\n            let debounceTimeout;\n            searchUsername.addEventListener('input', (e) => {\n                // Clear previous timeout\n                clearTimeout(debounceTimeout);\n                const inputValue = e.target.value;\n                // If input is empty, hide results\n                if (!inputValue.trim()) {\n                    searchResultsContainer.classList.add('hidden');\n                    return;\n                }\n                // Set a debounce to avoid too many API calls\n                debounceTimeout = setTimeout(() => {\n                    searchUsers(inputValue);\n                }, 300); // Debounce for 300ms\n            });\n        }\n        // Ajouter un gestionnaire de clic pour le bouton de fermeture des r√©sultats\n        const closeButton = document.getElementById('close-search-results');\n        if (closeButton) {\n            closeButton.addEventListener('click', () => {\n                searchResultsContainer.classList.add('hidden');\n                searchUserForm.reset();\n            });\n        }\n    }\n    // Event listener for friends search input\n    if (friendsSearch) {\n        friendsSearch.addEventListener('input', () => {\n            const query = friendsSearch.value.toLowerCase();\n            const friendItems = friendsContainer.querySelectorAll('.friend-item');\n            friendItems.forEach((item) => {\n                var _a, _b;\n                const username = ((_b = (_a = item.querySelector('.friend-username')) === null || _a === void 0 ? void 0 : _a.textContent) === null || _b === void 0 ? void 0 : _b.toLowerCase()) || '';\n                if (username.includes(query)) {\n                    item.style.display = '';\n                }\n                else {\n                    item.style.display = 'none';\n                }\n            });\n            // Show \"no results\" message if all friends are hidden\n            let allHidden = true;\n            friendItems.forEach((item) => {\n                if (item.style.display !== 'none') {\n                    allHidden = false;\n                }\n            });\n            if (allHidden && friendItems.length > 0) {\n                // Create or update no results message\n                let noResults = document.getElementById('no-search-results');\n                if (!noResults) {\n                    noResults = document.createElement('div');\n                    noResults.id = 'no-search-results';\n                    noResults.className = 'text-center py-4 text-gray-500';\n                    noResults.textContent = `Aucun ami trouv√© pour \"${query}\"`;\n                    friendsContainer.appendChild(noResults);\n                }\n                else {\n                    noResults.textContent = `Aucun ami trouv√© pour \"${query}\"`;\n                    noResults.classList.remove('hidden');\n                }\n            }\n            else {\n                // Hide no results message if it exists\n                const noResults = document.getElementById('no-search-results');\n                if (noResults) {\n                    noResults.classList.add('hidden');\n                }\n            }\n        });\n    }\n    // Initial data loading\n    function initialize() {\n        return __awaiter(this, void 0, void 0, function* () {\n            console.log('Initializing friends page');\n            try {\n                // V√©rifier si auth service est disponible et authentifi√©\n                if (authService && authService.isAuthenticated && authService.isAuthenticated()) {\n                    console.log('User is authenticated, ensuring token is available for WebSocket');\n                    // S'assurer que le token est disponible\n                    const token = authService.getToken();\n                    console.log('Token availability for WebSocket:', !!token);\n                    if (!token) {\n                        console.error('No token available, auth service getToken returned null');\n                        showNotification('Probl√®me d\\'authentification, veuillez vous reconnecter', 'error');\n                        setTimeout(() => {\n                            window.location.href = '/login.html';\n                        }, 2000);\n                        return;\n                    }\n                    // V√©rifier l'√©tat de la connexion WebSocket une seule fois\n                    const websocketService = window.websocketService;\n                    if (websocketService && !websocketService.isConnected()) {\n                        console.log('WebSocket service not connected, initiating connection');\n                        websocketService.connect();\n                    }\n                    else if (websocketService && websocketService.isConnected()) {\n                        console.log('WebSocket already connected');\n                    }\n                    else {\n                        console.warn('WebSocket service not available');\n                    }\n                }\n                // Load friends and friend requests in parallel\n                yield Promise.all([\n                    loadFriends(),\n                    loadFriendRequests()\n                ]);\n                // Configurer un intervalle pour rafra√Æchir r√©guli√®rement les demandes d'amiti√©\n                // Cela servira de fallback si WebSocket ne fonctionne pas\n                setInterval(() => {\n                    console.log('Refreshing friend requests...');\n                    loadFriendRequests();\n                }, 30000); // Rafra√Æchir toutes les 30 secondes au lieu de 5 pour r√©duire le spam\n                console.log('Friends page initialized successfully');\n            }\n            catch (error) {\n                console.error('Error initializing friends page:', error);\n                showNotification('Erreur lors du chargement des donn√©es', 'error');\n            }\n        });\n    }\n    // Initialize page\n    initialize();\n}));\n\n\n//# sourceURL=webpack://ft-transcendence-frontend/./src/ts/friends.ts?");

/***/ }),

/***/ "./src/ts/websocket.ts":
/*!*****************************!*\
  !*** ./src/ts/websocket.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   websocketService: () => (/* binding */ websocketService)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// WebSocket URL configuration\nconst WS_URL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'\n    ? 'http://localhost:3000'\n    : window.location.origin; // Use the same origin in production\n// Log the WebSocket URL for debugging\nconsole.log('[Socket.io] Using WebSocket URL:', WS_URL);\n// Constantes partag√©es avec auth.ts\nconst TOKEN_KEY = 'auth_token';\nclass WebSocketService {\n    constructor() {\n        this.socket = null; // Socket.io socket instead of WebSocket\n        this.listeners = new Map();\n        this.reconnectAttempts = 0;\n        this.maxReconnectAttempts = 3;\n        this.reconnectDelay = 3000;\n        this.isBackendAvailable = true;\n        this.connectionPromise = null;\n        this.isConnecting = false;\n    }\n    // Connect to the Socket.io server\n    connect() {\n        // Return existing connection promise if already connecting\n        if (this.connectionPromise) {\n            return this.connectionPromise;\n        }\n        if (this.socket && this.socket.connected) {\n            console.log('[Socket.io] Already connected');\n            return Promise.resolve(true);\n        }\n        if (!this.isBackendAvailable) {\n            console.log('[Socket.io] Backend previously marked as unavailable, skipping connection attempt');\n            return Promise.resolve(false);\n        }\n        // Create a new connection promise\n        this.connectionPromise = new Promise((resolve, reject) => {\n            this.isConnecting = true;\n            // Get token from auth service or storage\n            let token = null;\n            // Try to get token from auth service first\n            const authService = window.authService;\n            if (authService && authService.getToken && typeof authService.getToken === 'function') {\n                token = authService.getToken();\n                console.log('[Socket.io] Got token from authService:', !!token);\n            }\n            // Fallback to localStorage if token not available from auth service\n            if (!token) {\n                token = localStorage.getItem(TOKEN_KEY);\n                console.log('[Socket.io] Got token from localStorage:', !!token);\n            }\n            if (!token) {\n                console.log('[Socket.io] No token available for connection');\n                this.isConnecting = false;\n                this.connectionPromise = null;\n                resolve(false);\n                return;\n            }\n            try {\n                // Close any existing connection\n                this.disconnect();\n                // Import Socket.io client from CDN if not already available\n                if (typeof io === 'undefined') {\n                    console.log('[Socket.io] io not defined, loading script from CDN');\n                    const script = document.createElement('script');\n                    script.src = 'https://cdn.socket.io/4.6.0/socket.io.min.js';\n                    script.onload = () => this.initializeSocket(token, resolve, reject);\n                    script.onerror = () => {\n                        console.error('[Socket.io] Failed to load Socket.io script');\n                        this.isConnecting = false;\n                        this.connectionPromise = null;\n                        reject(new Error('Failed to load Socket.io script'));\n                    };\n                    document.head.appendChild(script);\n                }\n                else {\n                    this.initializeSocket(token, resolve, reject);\n                }\n            }\n            catch (error) {\n                console.error('[Socket.io] Setup error:', error);\n                this.isConnecting = false;\n                this.connectionPromise = null;\n                reject(error);\n            }\n        });\n        return this.connectionPromise;\n    }\n    // Initialize Socket.io connection\n    initializeSocket(token, resolve, reject) {\n        console.log('[Socket.io] Initializing connection');\n        try {\n            // Log the original token format for debugging\n            console.log('[Socket.io] Original token format:', token.startsWith('Bearer ') ? 'Has Bearer prefix' : 'No Bearer prefix');\n            // Remove Bearer prefix if it exists, to ensure we're not double-prefixing\n            const cleanToken = token.startsWith('Bearer ') ? token.substring(7) : token;\n            const tokenPreview = cleanToken.length > 20\n                ? cleanToken.substring(0, 15) + '...' + cleanToken.substring(cleanToken.length - 5)\n                : cleanToken;\n            console.log('[Socket.io] Token prepared for connection:', tokenPreview);\n            // Connect to Socket.io server with clean token (no Bearer prefix)\n            this.socket = io(WS_URL, {\n                auth: { token: cleanToken },\n                reconnection: true,\n                reconnectionAttempts: this.maxReconnectAttempts,\n                reconnectionDelay: this.reconnectDelay,\n                timeout: 10000\n            });\n            // Connection success\n            this.socket.on('connect', () => {\n                console.log('[Socket.io] Connected successfully');\n                this.reconnectAttempts = 0;\n                this.isBackendAvailable = true;\n                this.isConnecting = false;\n                this.connectionPromise = null;\n                // Wait a bit before reattaching listeners to ensure connection is stable\n                setTimeout(() => {\n                    this.reattachListeners();\n                    resolve(true);\n                }, 100);\n            });\n            // Connection error\n            this.socket.on('connect_error', (error) => {\n                console.error('[Socket.io] Connection error:', error);\n                this.reconnectAttempts++;\n                if (this.reconnectAttempts > this.maxReconnectAttempts) {\n                    console.log('[Socket.io] Max reconnect attempts reached, giving up');\n                    this.isBackendAvailable = false;\n                    this.isConnecting = false;\n                    this.connectionPromise = null;\n                    this.socket.disconnect();\n                    reject(error);\n                }\n            });\n            // Handle disconnect\n            this.socket.on('disconnect', (reason) => {\n                console.log(`[Socket.io] Disconnected: ${reason}`);\n                this.isConnecting = false;\n                this.connectionPromise = null;\n                // Auto-reconnect for certain disconnect reasons\n                if (reason === 'io server disconnect') {\n                    // Server initiated disconnect, try to reconnect\n                    setTimeout(() => {\n                        this.connect();\n                    }, 2000);\n                }\n            });\n            // Handle errors from server\n            this.socket.on('error', (data) => {\n                console.error('[Socket.io] Error from server:', data);\n                if (data && data.message) {\n                    console.error(`WebSocket Error: ${data.message}`);\n                }\n            });\n            // Setup handlers for standard events we're interested in\n            ['friend-request-received', 'friend-request-sent', 'friend-request-accepted',\n                'friend-request-rejected', 'friend-removed', 'friend-status-change',\n                'game-invitation', 'game-started'].forEach(event => {\n                this.socket.on(event, (data) => {\n                    var _a;\n                    console.log(`[Socket.io] Received ${event} event:`, data);\n                    // Add type field if not present\n                    if (!data.type) {\n                        data.type = event;\n                    }\n                    // Forward to our listeners\n                    if (this.listeners.has(event)) {\n                        (_a = this.listeners.get(event)) === null || _a === void 0 ? void 0 : _a.forEach(callback => callback(data));\n                    }\n                });\n            });\n        }\n        catch (error) {\n            console.error('[Socket.io] Initialization error:', error);\n            this.isConnecting = false;\n            this.connectionPromise = null;\n            reject(error);\n        }\n    }\n    // Disconnect from the Socket.io server\n    disconnect() {\n        if (this.socket) {\n            console.log('[Socket.io] Disconnecting');\n            this.socket.disconnect();\n            this.socket = null;\n        }\n        this.reconnectAttempts = 0;\n        this.isConnecting = false;\n        this.connectionPromise = null;\n    }\n    // Subscribe to an event\n    on(event, callback) {\n        var _a;\n        console.log(`[Socket.io] Registering event handler for: ${event}`);\n        if (!this.listeners.has(event)) {\n            this.listeners.set(event, new Set());\n        }\n        (_a = this.listeners.get(event)) === null || _a === void 0 ? void 0 : _a.add(callback);\n        // If already connected, register with socket.io server\n        if (this.socket && this.socket.connected) {\n            console.log(`[Socket.io] Already connected, subscribing to ${event}`);\n            // Remove existing listeners for this event to avoid duplicates\n            this.socket.off(event);\n            this.socket.on(event, (data) => {\n                console.log(`[Socket.io] Direct event ${event}:`, data);\n                // Add type if missing\n                if (!data.type) {\n                    data.type = event;\n                }\n                // Call all callbacks for this event\n                const eventCallbacks = this.listeners.get(event);\n                if (eventCallbacks) {\n                    eventCallbacks.forEach(cb => cb(data));\n                }\n            });\n        }\n    }\n    // Unsubscribe from an event\n    off(event, callback) {\n        const listeners = this.listeners.get(event);\n        if (listeners) {\n            listeners.delete(callback);\n            if (listeners.size === 0) {\n                this.listeners.delete(event);\n                // If connected, remove listener from socket.io\n                if (this.socket && this.socket.connected) {\n                    this.socket.off(event);\n                }\n            }\n        }\n    }\n    // Send a message to the server with connection check\n    send(type, data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Ensure we're connected before sending\n            if (!this.isConnected()) {\n                console.log('[Socket.io] Not connected, attempting to connect before sending message');\n                try {\n                    const connected = yield this.connect();\n                    if (!connected) {\n                        console.warn('[Socket.io] Failed to connect, cannot send message');\n                        return false;\n                    }\n                    // Wait a bit more to ensure connection is stable\n                    yield new Promise(resolve => setTimeout(resolve, 200));\n                }\n                catch (error) {\n                    console.error('[Socket.io] Connection failed:', error);\n                    return false;\n                }\n            }\n            if (!this.socket || !this.socket.connected) {\n                console.warn('[Socket.io] Cannot send message: not connected');\n                return false;\n            }\n            try {\n                console.log(`[Socket.io] Emitting ${type}:`, data);\n                this.socket.emit(type, data);\n                return true;\n            }\n            catch (error) {\n                console.error('[Socket.io] Error sending message:', error);\n                return false;\n            }\n        });\n    }\n    // Check if connected\n    isConnected() {\n        const connected = this.socket && this.socket.connected;\n        console.log('[Socket.io] Checking connection status:', connected || false);\n        return connected;\n    }\n    // Check if currently connecting\n    isCurrentlyConnecting() {\n        return this.isConnecting;\n    }\n    // Reattach all event listeners after reconnect\n    reattachListeners() {\n        if (!this.socket || !this.socket.connected)\n            return;\n        console.log('[Socket.io] Reattaching event listeners');\n        // Don't clear all listeners, just reattach our custom ones\n        this.listeners.forEach((callbacks, event) => {\n            console.log(`[Socket.io] Resubscribing to event: ${event}`);\n            // Remove existing listener for this event to avoid duplicates\n            this.socket.off(event);\n            this.socket.on(event, (data) => {\n                console.log(`[Socket.io] Received reattached ${event}:`, data);\n                // Add type if missing\n                if (!data.type) {\n                    data.type = event;\n                }\n                callbacks.forEach(callback => callback(data));\n            });\n        });\n    }\n    // Attempt to reconnect\n    attemptReconnect() {\n        this.reconnectAttempts++;\n        if (this.reconnectAttempts > this.maxReconnectAttempts) {\n            console.log('[Socket.io] Max reconnect attempts reached, giving up');\n            this.isBackendAvailable = false;\n            return;\n        }\n        const delay = Math.min(10000, this.reconnectDelay * Math.pow(1.5, this.reconnectAttempts - 1));\n        console.log(`[Socket.io] Attempting to reconnect in ${delay}ms (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\n        setTimeout(() => {\n            this.connect();\n        }, delay);\n    }\n}\n// Create a singleton instance\nconst websocketService = new WebSocketService();\n// Export the websocket service\n\n// Make it globally available\nwindow.websocketService = websocketService;\n// Auto-connect if user is authenticated\ndocument.addEventListener('DOMContentLoaded', () => __awaiter(void 0, void 0, void 0, function* () {\n    const token = localStorage.getItem('auth_token');\n    if (token) {\n        console.log('[Socket.io] Auto-connecting...');\n        try {\n            yield websocketService.connect();\n            console.log('[Socket.io] Auto-connection successful');\n        }\n        catch (error) {\n            console.error('[Socket.io] Auto-connection failed:', error);\n        }\n    }\n}));\n\n\n//# sourceURL=webpack://ft-transcendence-frontend/./src/ts/websocket.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/ts/friends.ts");
/******/ 	
/******/ })()
;