/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/ts/api.ts":
/*!***********************!*\
  !*** ./src/ts/api.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   api: () => (/* binding */ api),\n/* harmony export */   getAvatarUrl: () => (/* binding */ getAvatarUrl)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// API URL configuration\nconst API_URL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'\n    ? 'http://localhost:3000'\n    : window.location.origin; // Use the same origin in production\n// Helper for API requests\nfunction request(endpoint_1) {\n    return __awaiter(this, arguments, void 0, function* (endpoint, options = {}) {\n        try {\n            const url = `${API_URL}${endpoint}`;\n            console.log(`[API] Making ${options.method || 'GET'} request to: ${url}`);\n            // Get the most up-to-date token\n            const authService = window.authService;\n            let token;\n            if (authService && authService.getToken) {\n                // Get the token directly from auth service if available\n                token = authService.getToken();\n                console.log(`[API] Got token from authService: ${!!token}`);\n            }\n            else {\n                // Fallback to localStorage\n                token = localStorage.getItem('auth_token');\n                console.log(`[API] Got token from localStorage: ${!!token}`);\n            }\n            // Prepare headers - don't set Content-Type for FormData\n            const headers = Object.assign({ 'Accept': 'application/json' }, (token && { 'Authorization': `Bearer ${token}` }));\n            // Only set Content-Type if not FormData\n            if (!(options.body instanceof FormData)) {\n                headers['Content-Type'] = 'application/json';\n            }\n            // Add custom headers\n            Object.assign(headers, options.headers || {});\n            // Add a timeout to the fetch request\n            const controller = new AbortController();\n            const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout\n            const response = yield fetch(url, Object.assign(Object.assign({}, options), { headers, mode: 'cors', credentials: 'include', signal: controller.signal }));\n            clearTimeout(timeoutId); // Clear the timeout\n            console.log(`[API] Response status: ${response.status}`);\n            // Handle authentication errors\n            if (response.status === 401) {\n                console.log('[API] Authentication error (401) received');\n                // Use the auth service to clear the session if available\n                if (authService && authService.clearSession) {\n                    console.log('[API] Using authService to clear session');\n                    authService.clearSession();\n                }\n                else {\n                    // Fallback manual cleanup\n                    console.log('[API] Manually clearing auth data from storage');\n                    localStorage.removeItem('auth_token');\n                    localStorage.removeItem('user_id');\n                    localStorage.removeItem('username');\n                    localStorage.removeItem('avatar_url');\n                    sessionStorage.removeItem('auth_token');\n                    sessionStorage.removeItem('user_id');\n                    sessionStorage.removeItem('username');\n                    sessionStorage.removeItem('avatar_url');\n                }\n                // Get the current path and check if we need to redirect\n                const currentPath = window.location.pathname;\n                // Don't redirect if already on login page to avoid redirect loop\n                if (!currentPath.includes('login') && !currentPath.includes('register')) {\n                    console.log('[API] Redirecting to login page due to 401 error');\n                    window.location.href = '/login.html';\n                }\n                else {\n                    console.log('[API] Already on login/register page, not redirecting');\n                }\n                return {\n                    success: false,\n                    message: 'Authentication required'\n                };\n            }\n            // Handle 404 errors\n            if (response.status === 404) {\n                console.warn(`[API] Endpoint not found: ${endpoint}`);\n                return {\n                    success: false,\n                    message: `Endpoint not found: ${endpoint}`,\n                    data: [] // Renvoyer un tableau vide par défaut\n                };\n            }\n            // Handle no content response\n            if (response.status === 204) {\n                return { success: true };\n            }\n            let data;\n            try {\n                const text = yield response.text();\n                data = text ? JSON.parse(text) : {};\n            }\n            catch (error) {\n                console.error('Error parsing response:', error);\n                return {\n                    success: false,\n                    message: 'Failed to parse server response'\n                };\n            }\n            if (!response.ok) {\n                return {\n                    success: false,\n                    message: data.message || 'An error occurred'\n                };\n            }\n            return data;\n        }\n        catch (error) {\n            console.error('API request failed:', error);\n            if (error instanceof TypeError && error.message === 'Failed to fetch') {\n                console.warn('[API] Failed to fetch. The backend server may be down or unreachable.');\n                // Show a user-friendly message in the console that could be displayed to the user\n                console.log('[API] Connection to server failed. Please check if the backend is running.');\n            }\n            return {\n                success: false,\n                message: error instanceof Error ? error.message : 'Unknown error',\n                data: [] // Return an empty array by default\n            };\n        }\n    });\n}\n// Helper function to get avatar URL\nfunction getAvatarUrl(user) {\n    // Prioritize uploaded avatar data over URL\n    if (user.has_avatar_data) {\n        return `${API_URL}/users/avatar/${user.id}`;\n    }\n    // Fall back to avatar URL if available\n    if (user.avatar_url) {\n        return user.avatar_url;\n    }\n    // Return empty string - let the UI handle the default\n    return '';\n}\n// Create and export API object\nconst api = {\n    baseUrl: API_URL,\n    // Auth services\n    auth: {\n        login(email, password) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/auth/login', {\n                    method: 'POST',\n                    body: JSON.stringify({ email, password })\n                });\n            });\n        },\n        register(username, email, password) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/auth/register', {\n                    method: 'POST',\n                    body: JSON.stringify({ username, email, password })\n                });\n            });\n        },\n        logout() {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/auth/logout', {\n                    method: 'POST'\n                });\n            });\n        }\n    },\n    // User services\n    user: {\n        getProfile() {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/users/profile'); // Use /users/profile instead of /users/${id}\n            });\n        },\n        updateProfile(data) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/users/profile', {\n                    method: 'PUT', // Use PUT instead of PATCH to match backend\n                    body: JSON.stringify(data)\n                });\n            });\n        },\n        deleteProfile() {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/users/profile', {\n                    method: 'DELETE'\n                });\n            });\n        },\n        getMatches() {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/users/matches');\n            });\n        },\n        getAll() {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/users');\n            });\n        },\n        searchUsers(username) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request(`/users/search?username=${encodeURIComponent(username)}`);\n            });\n        },\n        // New avatar methods\n        uploadAvatar(file) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const formData = new FormData();\n                formData.append('file', file);\n                return request('/users/profile/avatar', {\n                    method: 'POST',\n                    body: formData\n                });\n            });\n        },\n        deleteAvatar() {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/users/profile/avatar', {\n                    method: 'DELETE'\n                });\n            });\n        }\n    },\n    // Friendship services\n    friendship: {\n        getFriends() {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/friendships');\n            });\n        },\n        getPendingRequests() {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/friendships/requests');\n            });\n        },\n        sendFriendRequest(friendId) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/friendships/request', {\n                    method: 'POST',\n                    body: JSON.stringify({ friend_id: friendId })\n                });\n            });\n        },\n        acceptFriendRequest(requestId) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request(`/friendships/accept/${requestId}`, {\n                    method: 'POST',\n                    body: JSON.stringify({})\n                });\n            });\n        },\n        rejectFriendRequest(requestId) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request(`/friendships/reject/${requestId}`, {\n                    method: 'POST',\n                    body: JSON.stringify({})\n                });\n            });\n        },\n        removeFriend(friendId) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request(`/friendships/${friendId}`, {\n                    method: 'DELETE'\n                });\n            });\n        }\n    },\n    // Game services\n    game: {\n        getAllMatches() {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/matches');\n            });\n        },\n        sendInvitation(friendId) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/games/invite', {\n                    method: 'POST',\n                    body: JSON.stringify({ friend_id: friendId })\n                });\n            });\n        }\n    }\n};\n// Pour la rétrocompatibilité, on expose aussi API globalement\nif (typeof window !== 'undefined') {\n    window.api = api;\n    window.getAvatarUrl = getAvatarUrl;\n}\n\n\n//# sourceURL=webpack://ft-transcendence-frontend/./src/ts/api.ts?");

/***/ }),

/***/ "./src/ts/friends.ts":
/*!***************************!*\
  !*** ./src/ts/friends.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api */ \"./src/ts/api.ts\");\n/* harmony import */ var _websocket__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./websocket */ \"./src/ts/websocket.ts\");\n// This file will be compiled to JS and included in the HTML directly\n// Global services and types will be available\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\ndocument.addEventListener('DOMContentLoaded', () => __awaiter(void 0, void 0, void 0, function* () {\n    console.log('Friends page loaded');\n    // Get services from global scope\n    const authService = window.authService;\n    console.log('Auth service available:', !!authService);\n    // Check if services are available\n    if (!_api__WEBPACK_IMPORTED_MODULE_0__.api || !_api__WEBPACK_IMPORTED_MODULE_0__.api.friendship) {\n        console.error('API or friendship module not available');\n        window.location.href = '/login.html';\n        return;\n    }\n    // Force auth service to refresh token state from storage\n    if (authService && authService.restoreSession) {\n        console.log('Friends: Restoring auth session');\n        authService.restoreSession();\n    }\n    // Check if user is authenticated properly using authService\n    const isAuthenticated = authService &&\n        authService.isAuthenticated &&\n        typeof authService.isAuthenticated === 'function' &&\n        authService.isAuthenticated();\n    console.log('Friends: User is authenticated:', isAuthenticated);\n    if (!isAuthenticated) {\n        console.log('Friends: User not authenticated, redirecting to login');\n        window.location.href = '/login.html';\n        return;\n    }\n    // Vérifier explicitement que le token est disponible\n    const token = authService.getToken();\n    console.log('Friends: Auth token available:', !!token);\n    if (!token) {\n        console.log('Friends: No auth token available, redirecting to login');\n        authService.clearSession();\n        window.location.href = '/login.html';\n        return;\n    }\n    // Connect to WebSocket if available\n    if (_websocket__WEBPACK_IMPORTED_MODULE_1__.websocketService && _websocket__WEBPACK_IMPORTED_MODULE_1__.websocketService.connect) {\n        console.log('Connecting to WebSocket with auth token');\n        _websocket__WEBPACK_IMPORTED_MODULE_1__.websocketService.connect();\n        // Vérifier la connexion après un court délai\n        setTimeout(() => {\n            if (_websocket__WEBPACK_IMPORTED_MODULE_1__.websocketService.isConnected && _websocket__WEBPACK_IMPORTED_MODULE_1__.websocketService.isConnected()) {\n                console.log('WebSocket successfully connected!');\n            }\n            else {\n                console.log('WebSocket connection failed, retrying once more...');\n                _websocket__WEBPACK_IMPORTED_MODULE_1__.websocketService.connect();\n            }\n        }, 1000);\n    }\n    // DOM elements\n    const friendsContainer = document.getElementById('friends-container');\n    const noFriends = document.getElementById('no-friends');\n    const friendTemplate = document.getElementById('friend-template');\n    const friendRequestsContainer = document.getElementById('friend-requests-container');\n    const noFriendRequests = document.getElementById('no-friend-requests');\n    const friendRequestTemplate = document.getElementById('friend-request-template');\n    const searchUserForm = document.getElementById('search-user-form');\n    const searchUsername = document.getElementById('search-username');\n    const searchResultsContainer = document.getElementById('search-results-container');\n    const searchResults = document.getElementById('search-results');\n    const searchResultTemplate = document.getElementById('search-result-template');\n    const searchError = document.getElementById('search-error');\n    const searchErrorText = document.getElementById('search-error-text');\n    const friendsSearch = document.getElementById('friends-search');\n    // Register WebSocket event handlers if available\n    if (_websocket__WEBPACK_IMPORTED_MODULE_1__.websocketService && _websocket__WEBPACK_IMPORTED_MODULE_1__.websocketService.on) {\n        console.log('Setting up WebSocket event handlers');\n        // Écouteur pour recevoir une demande d'ami\n        _websocket__WEBPACK_IMPORTED_MODULE_1__.websocketService.on('friend-request-received', (data) => {\n            var _a;\n            console.log('Received friend request via WebSocket:', data);\n            // Correction du format des données - chercher le nom d'utilisateur au bon endroit\n            const username = ((_a = data.from) === null || _a === void 0 ? void 0 : _a.username) || 'Quelqu\\'un';\n            // Recharger les demandes d'amitié en attente\n            loadFriendRequests();\n            // Afficher une notification\n            showNotification(`Nouvelle demande d'ami de ${username}`);\n            // Forcer le rechargement après un court délai pour s'assurer que les données sont à jour\n            setTimeout(() => {\n                loadFriendRequests();\n            }, 500);\n        });\n        // Écouteur pour les demandes envoyées\n        _websocket__WEBPACK_IMPORTED_MODULE_1__.websocketService.on('friend-request-sent', (data) => {\n            console.log('Friend request sent via WebSocket:', data);\n            // Trouver et mettre à jour le bouton d'ajout dans l'interface si présent\n            const searchResultItem = document.querySelector(`.search-result-item[data-id=\"${data.friend_id}\"]`);\n            if (searchResultItem) {\n                const sendButton = searchResultItem.querySelector('.add-friend-button');\n                if (sendButton) {\n                    sendButton.innerHTML = '<i class=\"fas fa-check mr-2\"></i> Demande envoyée';\n                    sendButton.classList.remove('bg-blue-600', 'hover:bg-blue-700');\n                    sendButton.classList.add('bg-green-600', 'cursor-not-allowed');\n                    sendButton.disabled = true;\n                }\n            }\n            showNotification(`Demande d'ami envoyée à ${data.friend_username || 'un utilisateur'}`);\n        });\n        // Écouteur quand une demande d'ami est acceptée\n        _websocket__WEBPACK_IMPORTED_MODULE_1__.websocketService.on('friend-request-accepted', (data) => {\n            console.log('Friend request accepted via WebSocket:', data);\n            // Recharger la liste d'amis\n            loadFriends();\n            // Afficher une notification\n            showNotification(`${data.friend_username || 'Quelqu\\'un'} a accepté votre demande d'ami`);\n        });\n        // Écouteur pour la réponse (acceptation ou rejet) envoyée\n        _websocket__WEBPACK_IMPORTED_MODULE_1__.websocketService.on('friend-request-response-sent', (data) => {\n            console.log('Friend request response sent via WebSocket:', data);\n            const action = data.accepted ? 'acceptée' : 'rejetée';\n            showNotification(`Demande d'ami ${action}`);\n            // Si c'est une acceptation, recharger la liste d'amis\n            if (data.accepted) {\n                loadFriends();\n            }\n        });\n        // Écouteur pour la suppression d'amitié\n        _websocket__WEBPACK_IMPORTED_MODULE_1__.websocketService.on('friend-removed', (data) => {\n            console.log('Friend removed via WebSocket:', data);\n            if (data.friend_id) {\n                // Si on est notifié qu'un ami nous a retiré\n                showNotification(`Un utilisateur vous a retiré de sa liste d'amis`, 'info');\n                loadFriends(); // Rafraîchir la liste d'amis\n            }\n            else {\n                // Confirmation de notre suppression\n                showNotification(`Ami supprimé avec succès`, 'success');\n            }\n        });\n        // Écouteur pour les changements de statut d'amis\n        _websocket__WEBPACK_IMPORTED_MODULE_1__.websocketService.on('friend-status-change', (data) => {\n            console.log('Friend status changed via WebSocket:', data);\n            updateFriendStatus(data.friend_id, data.status);\n        });\n        // Écoute des erreurs generales\n        _websocket__WEBPACK_IMPORTED_MODULE_1__.websocketService.on('error', (data) => {\n            console.error('Error from WebSocket:', data);\n            if (data.message) {\n                showNotification(`Erreur: ${data.message}`, 'error');\n            }\n        });\n    }\n    else {\n        console.warn('WebSocket service not available for event handling');\n    }\n    // Function to show notification\n    function showNotification(message, type = 'info') {\n        // Supprimer les notifications existantes\n        const existingNotifications = document.querySelectorAll('.toast-notification');\n        existingNotifications.forEach(notif => notif.remove());\n        // Créer un élément de notification\n        const notification = document.createElement('div');\n        notification.className = `toast-notification toast-${type} flex items-center text-white rounded-lg shadow-lg`;\n        // Définir l'icône en fonction du type\n        let icon = '';\n        switch (type) {\n            case 'success':\n                icon = '<i class=\"fas fa-check-circle text-xl mr-3\"></i>';\n                break;\n            case 'error':\n                icon = '<i class=\"fas fa-exclamation-circle text-xl mr-3\"></i>';\n                break;\n            default:\n                icon = '<i class=\"fas fa-info-circle text-xl mr-3\"></i>';\n        }\n        // Ajouter le contenu HTML (icône + message)\n        notification.innerHTML = `\n            ${icon}\n            <div>\n                <p class=\"font-medium\">${message}</p>\n            </div>\n            <button class=\"ml-auto pl-3 text-white/80 hover:text-white\">\n                <i class=\"fas fa-times\"></i>\n            </button>\n        `;\n        // Ajouter au body\n        document.body.appendChild(notification);\n        // Ajouter la classe show après un court délai (pour l'animation)\n        setTimeout(() => {\n            notification.classList.add('show');\n        }, 10);\n        // Ajouter un gestionnaire d'événement pour le bouton de fermeture\n        const closeButton = notification.querySelector('button');\n        if (closeButton) {\n            closeButton.addEventListener('click', () => {\n                notification.classList.remove('show');\n                setTimeout(() => {\n                    notification.remove();\n                }, 300);\n            });\n        }\n        // Supprimer après 5 secondes\n        setTimeout(() => {\n            notification.classList.remove('show');\n            setTimeout(() => {\n                notification.remove();\n            }, 300);\n        }, 5000);\n    }\n    // Function to update friend status in UI\n    function updateFriendStatus(userId, newStatus) {\n        console.log(`Updating friend status for user ${userId} to ${newStatus}`);\n        if (!userId) {\n            console.warn('No user ID provided for status update');\n            return;\n        }\n        const friendItem = document.querySelector(`.friend-item[data-id=\"${userId}\"]`);\n        if (!friendItem) {\n            console.warn(`Friend item with id ${userId} not found in the DOM`);\n            return;\n        }\n        const statusIndicator = friendItem.querySelector('.friend-status-indicator');\n        const status = friendItem.querySelector('.friend-status');\n        if (!statusIndicator || !status) {\n            console.warn('Status elements not found in friend item');\n            return;\n        }\n        // Remove existing status classes\n        statusIndicator.classList.remove('bg-green-500', 'bg-blue-500', 'bg-gray-500');\n        // Set new status\n        if (newStatus === 'online') {\n            statusIndicator.classList.add('bg-green-500');\n            status.textContent = 'En ligne';\n        }\n        else if (newStatus === 'in_game') {\n            statusIndicator.classList.add('bg-blue-500');\n            status.textContent = 'En jeu';\n        }\n        else {\n            statusIndicator.classList.add('bg-gray-500');\n            status.textContent = 'Hors ligne';\n        }\n    }\n    // Function to load friends list\n    function loadFriends() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const response = yield _api__WEBPACK_IMPORTED_MODULE_0__.api.friendship.getFriends();\n                if (response.success && response.data) {\n                    const friends = response.data;\n                    if (friends.length > 0) {\n                        // Hide no friends message\n                        noFriends.classList.add('hidden');\n                        friendsContainer.innerHTML = '';\n                        // Add each friend to the container\n                        friends.forEach((friend) => {\n                            addFriendToUI(friend);\n                        });\n                    }\n                    else {\n                        // Show no friends message\n                        noFriends.classList.remove('hidden');\n                        friendsContainer.innerHTML = '';\n                    }\n                }\n                else {\n                    console.error('Failed to load friends:', response.message);\n                }\n            }\n            catch (error) {\n                console.error('Error loading friends:', error);\n            }\n        });\n    }\n    // Function to add a friend to the UI\n    function addFriendToUI(friend) {\n        const friendElement = document.importNode(friendTemplate.content, true);\n        // Set friend details\n        const username = friendElement.querySelector('.friend-username');\n        const avatar = friendElement.querySelector('.friend-avatar');\n        const statusIndicator = friendElement.querySelector('.friend-status-indicator');\n        const status = friendElement.querySelector('.friend-status');\n        const inviteButton = friendElement.querySelector('.invite-game-button');\n        const removeButton = friendElement.querySelector('.remove-friend-button');\n        // Set username\n        username.textContent = friend.username;\n        // Set avatar if available\n        if (friend.avatar_url) {\n            avatar.innerHTML = `<img src=\"${friend.avatar_url}\" alt=\"${friend.username}\" class=\"w-full h-full object-cover\">`;\n        }\n        // Set status indicator color and text\n        if (friend.status === 'online') {\n            statusIndicator.classList.add('bg-green-500');\n            status.textContent = 'En ligne';\n        }\n        else if (friend.status === 'in_game') {\n            statusIndicator.classList.add('bg-blue-500');\n            status.textContent = 'En jeu';\n        }\n        else {\n            statusIndicator.classList.add('bg-gray-500');\n            status.textContent = 'Hors ligne';\n        }\n        // Add friend ID as data attribute\n        const friendItem = friendElement.querySelector('.friend-item');\n        friendItem.dataset.id = friend.id.toString();\n        // Ajouter un effet hover au bouton de suppression\n        removeButton.addEventListener('mouseenter', () => {\n            removeButton.innerHTML = '<i class=\"fas fa-user-times\"></i>';\n        });\n        removeButton.addEventListener('mouseleave', () => {\n            removeButton.innerHTML = '<i class=\"fas fa-times\"></i>';\n        });\n        // Add event listener to remove button\n        removeButton.addEventListener('click', () => __awaiter(this, void 0, void 0, function* () {\n            try {\n                // Afficher une confirmation avec un style moderne\n                const confirmDialog = document.createElement('div');\n                confirmDialog.className = 'fixed inset-0 flex items-center justify-center z-50';\n                confirmDialog.innerHTML = `\n                    <div class=\"absolute inset-0 bg-black bg-opacity-50 backdrop-blur-sm transition-opacity\"></div>\n                    <div class=\"bg-dark-800 rounded-xl shadow-2xl border border-dark-600 p-6 max-w-sm w-full mx-4 z-10 transform transition-all scale-95 opacity-0\">\n                        <div class=\"flex items-center justify-center mb-4 text-yellow-400\">\n                            <i class=\"fas fa-exclamation-triangle text-3xl\"></i>\n                        </div>\n                        <h3 class=\"text-xl font-medium text-center text-white mb-4\">Confirmer la suppression</h3>\n                        <p class=\"text-gray-300 mb-5 text-center\">Êtes-vous sûr de vouloir supprimer <span class=\"font-medium text-white\">${friend.username}</span> de votre liste d'amis ?</p>\n                        <div class=\"flex space-x-3 justify-center\">\n                            <button class=\"confirm-cancel-btn px-4 py-2 rounded-lg bg-dark-700 hover:bg-dark-600 text-white transition-colors\">\n                                Annuler\n                            </button>\n                            <button class=\"confirm-delete-btn px-4 py-2 rounded-lg bg-gradient-to-r from-red-500 to-red-600 hover:from-red-600 hover:to-red-700 text-white transition-colors\">\n                                Supprimer\n                            </button>\n                        </div>\n                    </div>\n                `;\n                document.body.appendChild(confirmDialog);\n                // Animer l'apparition\n                setTimeout(() => {\n                    const dialogContent = confirmDialog.querySelector('div:nth-child(2)');\n                    if (dialogContent) {\n                        dialogContent.classList.remove('scale-95', 'opacity-0');\n                        dialogContent.classList.add('scale-100', 'opacity-100');\n                    }\n                }, 10);\n                // Configurer les événements\n                const cancelBtn = confirmDialog.querySelector('.confirm-cancel-btn');\n                const deleteBtn = confirmDialog.querySelector('.confirm-delete-btn');\n                return new Promise((resolve) => {\n                    if (cancelBtn) {\n                        cancelBtn.addEventListener('click', () => {\n                            // Animer la disparition\n                            const dialogContent = confirmDialog.querySelector('div:nth-child(2)');\n                            if (dialogContent) {\n                                dialogContent.classList.remove('scale-100', 'opacity-100');\n                                dialogContent.classList.add('scale-95', 'opacity-0');\n                            }\n                            setTimeout(() => {\n                                document.body.removeChild(confirmDialog);\n                                resolve(false);\n                            }, 200);\n                        });\n                    }\n                    if (deleteBtn) {\n                        deleteBtn.addEventListener('click', () => __awaiter(this, void 0, void 0, function* () {\n                            // Animer la disparition\n                            const dialogContent = confirmDialog.querySelector('div:nth-child(2)');\n                            if (dialogContent) {\n                                dialogContent.classList.remove('scale-100', 'opacity-100');\n                                dialogContent.classList.add('scale-95', 'opacity-0');\n                            }\n                            setTimeout(() => {\n                                document.body.removeChild(confirmDialog);\n                                resolve(true);\n                            }, 200);\n                            // Désactiver le bouton pour éviter les clics multiples\n                            removeButton.disabled = true;\n                            removeButton.innerHTML = '<i class=\"fas fa-spinner fa-spin\"></i>';\n                            removeButton.classList.add('opacity-75');\n                            // Utiliser WebSocket si disponible\n                            const websocketService = window.websocketService;\n                            if (websocketService && websocketService.isConnected && websocketService.isConnected()) {\n                                console.log('Removing friend via WebSocket');\n                                websocketService.send('friend-remove', { friendId: friend.id });\n                                // Animer la disparition de l'ami\n                                friendItem.style.transition = 'all 0.3s ease-out';\n                                friendItem.style.transform = 'translateX(10px)';\n                                friendItem.style.opacity = '0';\n                                setTimeout(() => {\n                                    // Remove friend from UI\n                                    friendItem.remove();\n                                    // Check if friends list is empty\n                                    if (friendsContainer.children.length === 0) {\n                                        noFriends.classList.remove('hidden');\n                                    }\n                                }, 300);\n                                // Afficher une notification\n                                showNotification(`${friend.username} a été retiré de vos amis`, 'info');\n                            }\n                            else {\n                                // Fallback à l'API REST\n                                console.log('WebSocket not available, using REST API');\n                                const response = yield _api__WEBPACK_IMPORTED_MODULE_0__.api.friendship.removeFriend(friend.id);\n                                if (response.success) {\n                                    // Animer la disparition de l'ami\n                                    friendItem.style.transition = 'all 0.3s ease-out';\n                                    friendItem.style.transform = 'translateX(10px)';\n                                    friendItem.style.opacity = '0';\n                                    setTimeout(() => {\n                                        // Remove friend from UI\n                                        friendItem.remove();\n                                        // Check if friends list is empty\n                                        if (friendsContainer.children.length === 0) {\n                                            noFriends.classList.remove('hidden');\n                                        }\n                                    }, 300);\n                                    // Afficher une notification\n                                    showNotification(`${friend.username} a été retiré de vos amis`, 'info');\n                                }\n                                else {\n                                    console.error('Failed to remove friend:', response.message);\n                                    showNotification(`Erreur: ${response.message}`, 'error');\n                                    // Réactiver le bouton en cas d'erreur\n                                    removeButton.disabled = false;\n                                    removeButton.innerHTML = '<i class=\"fas fa-times\"></i>';\n                                    removeButton.classList.remove('opacity-75');\n                                }\n                            }\n                        }));\n                    }\n                });\n            }\n            catch (error) {\n                console.error('Error removing friend:', error);\n                showNotification('Une erreur est survenue', 'error');\n            }\n        }));\n        // Add event listener to invite button\n        inviteButton.addEventListener('click', () => {\n            // Montrer animation sur le bouton pour indiquer que l'invitation est envoyée\n            inviteButton.disabled = true;\n            inviteButton.innerHTML = '<i class=\"fas fa-spinner fa-spin mr-1.5\"></i> Envoi...';\n            inviteButton.classList.add('opacity-75');\n            // Send game invitation via API\n            sendGameInvitation(friend.id, friend.username);\n            // Rétablir le bouton après un court délai\n            setTimeout(() => {\n                inviteButton.disabled = false;\n                inviteButton.innerHTML = '<i class=\"fas fa-gamepad mr-1.5\"></i> Jouer';\n                inviteButton.classList.remove('opacity-75');\n            }, 1500);\n        });\n        // Add to container\n        friendsContainer.appendChild(friendElement);\n    }\n    // Function to send game invitation\n    function sendGameInvitation(friendId, friendUsername) {\n        // Check if websocket available\n        const websocketService = window.websocketService;\n        if (websocketService && websocketService.send) {\n            // Send game invitation via WebSocket\n            websocketService.send('game-invite', {\n                friendId: friendId,\n                friendUsername: friendUsername\n            });\n            showNotification(`Invitation envoyée à ${friendUsername}`, 'success');\n        }\n        else {\n            // Fallback to API\n            _api__WEBPACK_IMPORTED_MODULE_0__.api.game.sendInvitation(friendId)\n                .then((response) => {\n                if (response.success) {\n                    showNotification(`Invitation envoyée à ${friendUsername}`, 'success');\n                }\n                else {\n                    showNotification(`Erreur: ${response.message}`, 'error');\n                }\n            })\n                .catch((error) => {\n                console.error('Error sending game invitation:', error);\n                showNotification(\"Erreur lors de l'envoi de l'invitation\", 'error');\n            });\n        }\n    }\n    // Function to load friend requests\n    function loadFriendRequests() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                console.log('Loading friend requests...');\n                const response = yield _api__WEBPACK_IMPORTED_MODULE_0__.api.friendship.getPendingRequests();\n                console.log('Friend requests API response:', response);\n                if (response.success && response.data) {\n                    const requests = response.data;\n                    if (requests.length > 0) {\n                        // Hide no requests message\n                        noFriendRequests.classList.add('hidden');\n                        friendRequestsContainer.innerHTML = '';\n                        // Add each request to the container\n                        requests.forEach((request) => {\n                            console.log('Processing friend request:', request);\n                            addFriendRequestToUI(request);\n                        });\n                    }\n                    else {\n                        // Show no requests message\n                        noFriendRequests.classList.remove('hidden');\n                        friendRequestsContainer.innerHTML = '';\n                    }\n                }\n                else {\n                    console.error('Failed to load friend requests:', response.message);\n                }\n            }\n            catch (error) {\n                console.error('Error loading friend requests:', error);\n            }\n        });\n    }\n    // Function to add a friend request to the UI\n    function addFriendRequestToUI(request) {\n        console.log('Adding request to UI:', request);\n        // Vérifier que l'objet user ou sender existe\n        if (!request.user && !request.sender) {\n            console.error('Friend request missing user data:', request);\n            return;\n        }\n        // Utiliser sender si user n'existe pas\n        const userData = request.user || request.sender;\n        const requestElement = document.importNode(friendRequestTemplate.content, true);\n        // Set request details\n        const username = requestElement.querySelector('.request-username');\n        const avatar = requestElement.querySelector('.request-avatar');\n        const dateContainer = requestElement.querySelector('.request-date');\n        const dateSpan = dateContainer.querySelector('span');\n        const acceptButton = requestElement.querySelector('.accept-request-button');\n        const rejectButton = requestElement.querySelector('.reject-request-button');\n        // Set username and date\n        username.textContent = userData.username;\n        // Format date plus élégamment\n        const requestDate = new Date(request.created_at || new Date());\n        const now = new Date();\n        const diffTime = Math.abs(now.getTime() - requestDate.getTime());\n        const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));\n        const diffHours = Math.floor(diffTime / (1000 * 60 * 60));\n        const diffMinutes = Math.floor(diffTime / (1000 * 60));\n        // Afficher la date de manière plus humaine\n        if (diffMinutes < 1) {\n            dateSpan.textContent = `À l'instant`;\n        }\n        else if (diffMinutes < 60) {\n            dateSpan.textContent = `Il y a ${diffMinutes} minute${diffMinutes > 1 ? 's' : ''}`;\n        }\n        else if (diffHours < 24) {\n            dateSpan.textContent = `Il y a ${diffHours} heure${diffHours > 1 ? 's' : ''}`;\n        }\n        else if (diffDays < 7) {\n            dateSpan.textContent = `Il y a ${diffDays} jour${diffDays > 1 ? 's' : ''}`;\n        }\n        else {\n            dateSpan.textContent = `Le ${requestDate.toLocaleDateString()}`;\n        }\n        // Set avatar if available\n        if (userData.avatar_url) {\n            avatar.innerHTML = `<img src=\"${userData.avatar_url}\" alt=\"${userData.username}\" class=\"w-full h-full object-cover\">`;\n        }\n        // Add request ID as data attribute\n        const requestItem = requestElement.querySelector('.friend-request-item');\n        requestItem.dataset.id = request.id.toString();\n        // Store the user ID for accept/reject actions\n        const userId = userData.id;\n        requestItem.dataset.userId = userId.toString();\n        // Add event listener to accept button\n        acceptButton.addEventListener('click', () => __awaiter(this, void 0, void 0, function* () {\n            try {\n                // Désactiver les boutons pour éviter les clics multiples\n                acceptButton.disabled = true;\n                rejectButton.disabled = true;\n                // Changer l'apparence du bouton pour indiquer le traitement\n                acceptButton.innerHTML = '<i class=\"fas fa-spinner fa-spin mr-1.5\"></i> Acceptation...';\n                acceptButton.classList.add('opacity-75');\n                rejectButton.classList.add('opacity-50');\n                // Utiliser WebSocket si disponible\n                const websocketService = window.websocketService;\n                if (websocketService && websocketService.isConnected && websocketService.isConnected()) {\n                    console.log('Accepting friend request via WebSocket');\n                    websocketService.send('friend-request-response', {\n                        friendId: userId,\n                        accept: true\n                    });\n                    // Animer la disparition de la demande\n                    requestItem.style.transition = 'all 0.3s ease-out';\n                    requestItem.style.transform = 'translateX(10px)';\n                    requestItem.style.opacity = '0';\n                    setTimeout(() => {\n                        // Remove request from UI\n                        requestItem.remove();\n                        // Check if requests list is empty\n                        if (friendRequestsContainer.children.length === 0) {\n                            noFriendRequests.classList.remove('hidden');\n                        }\n                    }, 300);\n                    // Reload friends list\n                    loadFriends();\n                    // Afficher une notification\n                    showNotification(`Vous êtes maintenant ami avec ${userData.username}`, 'success');\n                }\n                else {\n                    // Fallback à l'API REST\n                    console.log('WebSocket not available, using REST API');\n                    const response = yield _api__WEBPACK_IMPORTED_MODULE_0__.api.friendship.acceptFriendRequest(request.id);\n                    if (response.success) {\n                        // Animer la disparition de la demande\n                        requestItem.style.transition = 'all 0.3s ease-out';\n                        requestItem.style.transform = 'translateX(10px)';\n                        requestItem.style.opacity = '0';\n                        setTimeout(() => {\n                            // Remove request from UI\n                            requestItem.remove();\n                            // Check if requests list is empty\n                            if (friendRequestsContainer.children.length === 0) {\n                                noFriendRequests.classList.remove('hidden');\n                            }\n                        }, 300);\n                        // Reload friends list\n                        loadFriends();\n                        // Afficher une notification\n                        showNotification(`Vous êtes maintenant ami avec ${userData.username}`, 'success');\n                    }\n                    else {\n                        console.error('Failed to accept friend request:', response.message);\n                        showNotification(`Erreur: ${response.message}`, 'error');\n                        // Réactiver les boutons en cas d'erreur\n                        acceptButton.disabled = false;\n                        rejectButton.disabled = false;\n                        acceptButton.innerHTML = '<i class=\"fas fa-check mr-1.5\"></i> Accepter';\n                        acceptButton.classList.remove('opacity-75');\n                        rejectButton.classList.remove('opacity-50');\n                    }\n                }\n            }\n            catch (error) {\n                console.error('Error accepting friend request:', error);\n                showNotification('Une erreur est survenue', 'error');\n                // Réactiver les boutons en cas d'erreur\n                acceptButton.disabled = false;\n                rejectButton.disabled = false;\n                acceptButton.innerHTML = '<i class=\"fas fa-check mr-1.5\"></i> Accepter';\n                acceptButton.classList.remove('opacity-75');\n                rejectButton.classList.remove('opacity-50');\n            }\n        }));\n        // Add event listener to reject button with the same pattern\n        rejectButton.addEventListener('click', () => __awaiter(this, void 0, void 0, function* () {\n            try {\n                // Désactiver les boutons pour éviter les clics multiples\n                rejectButton.disabled = true;\n                acceptButton.disabled = true;\n                // Changer l'apparence du bouton pour indiquer le traitement\n                rejectButton.innerHTML = '<i class=\"fas fa-spinner fa-spin mr-1.5\"></i> Refus...';\n                rejectButton.classList.add('opacity-75');\n                acceptButton.classList.add('opacity-50');\n                // Utiliser WebSocket si disponible\n                const websocketService = window.websocketService;\n                if (websocketService && websocketService.isConnected && websocketService.isConnected()) {\n                    console.log('Rejecting friend request via WebSocket');\n                    websocketService.send('friend-request-response', {\n                        friendId: userId,\n                        accept: false\n                    });\n                    // Animer la disparition de la demande\n                    requestItem.style.transition = 'all 0.3s ease-out';\n                    requestItem.style.transform = 'translateX(10px)';\n                    requestItem.style.opacity = '0';\n                    setTimeout(() => {\n                        // Remove request from UI\n                        requestItem.remove();\n                        // Check if requests list is empty\n                        if (friendRequestsContainer.children.length === 0) {\n                            noFriendRequests.classList.remove('hidden');\n                        }\n                    }, 300);\n                }\n                else {\n                    // Fallback à l'API REST\n                    console.log('WebSocket not available, using REST API');\n                    const response = yield _api__WEBPACK_IMPORTED_MODULE_0__.api.friendship.rejectFriendRequest(request.id);\n                    if (response.success) {\n                        // Animer la disparition de la demande\n                        requestItem.style.transition = 'all 0.3s ease-out';\n                        requestItem.style.transform = 'translateX(10px)';\n                        requestItem.style.opacity = '0';\n                        setTimeout(() => {\n                            // Remove request from UI\n                            requestItem.remove();\n                            // Check if requests list is empty\n                            if (friendRequestsContainer.children.length === 0) {\n                                noFriendRequests.classList.remove('hidden');\n                            }\n                        }, 300);\n                    }\n                    else {\n                        console.error('Failed to reject friend request:', response.message);\n                        showNotification(`Erreur: ${response.message}`, 'error');\n                        // Réactiver les boutons en cas d'erreur\n                        rejectButton.disabled = false;\n                        acceptButton.disabled = false;\n                        rejectButton.innerHTML = '<i class=\"fas fa-times mr-1.5\"></i> Refuser';\n                        rejectButton.classList.remove('opacity-75');\n                        acceptButton.classList.remove('opacity-50');\n                    }\n                }\n            }\n            catch (error) {\n                console.error('Error rejecting friend request:', error);\n                showNotification('Une erreur est survenue', 'error');\n                // Réactiver les boutons en cas d'erreur\n                rejectButton.disabled = false;\n                acceptButton.disabled = false;\n                rejectButton.innerHTML = '<i class=\"fas fa-times mr-1.5\"></i> Refuser';\n                rejectButton.classList.remove('opacity-75');\n                acceptButton.classList.remove('opacity-50');\n            }\n        }));\n        // Add to container\n        friendRequestsContainer.appendChild(requestElement);\n    }\n    // Function to search for users\n    function searchUsers(username) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                searchResults.innerHTML = '';\n                if (!username.trim()) {\n                    searchResultsContainer.classList.add('hidden');\n                    return;\n                }\n                // Show loading state\n                searchResults.innerHTML = `\n                <div class=\"text-center py-4\">\n                    <svg class=\"animate-spin h-8 w-8 mx-auto text-blue-600\" xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\">\n                        <circle class=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" stroke-width=\"4\"></circle>\n                        <path class=\"opacity-75\" fill=\"currentColor\" d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"></path>\n                    </svg>\n                </div>\n            `;\n                searchResultsContainer.classList.remove('hidden');\n                // Search users via API\n                const response = yield _api__WEBPACK_IMPORTED_MODULE_0__.api.user.searchUsers(username);\n                if (response.success) {\n                    const data = response.data;\n                    searchResults.innerHTML = '';\n                    if (data.length > 0) {\n                        data.forEach((user) => {\n                            addSearchResultToUI(user);\n                        });\n                    }\n                    else {\n                        searchResults.innerHTML = `\n                        <div class=\"text-center py-4 text-gray-500\">\n                            Aucun utilisateur trouvé pour \"${username}\"\n                        </div>\n                    `;\n                    }\n                }\n                else {\n                    throw new Error(response.message || 'Failed to search users');\n                }\n            }\n            catch (error) {\n                console.error('Error searching users:', error);\n                searchError.classList.remove('hidden');\n                searchErrorText.textContent = 'Erreur lors de la recherche. Veuillez réessayer.';\n                // Hide error after 3 seconds\n                setTimeout(() => {\n                    searchError.classList.add('hidden');\n                }, 3000);\n            }\n        });\n    }\n    // Function to add a search result to the UI\n    function addSearchResultToUI(user) {\n        const resultElement = document.importNode(searchResultTemplate.content, true);\n        // Set user details\n        const username = resultElement.querySelector('.result-username');\n        const avatar = resultElement.querySelector('.result-avatar');\n        const sendButton = resultElement.querySelector('.add-friend-button');\n        // Set username\n        username.textContent = user.username;\n        // Set avatar if available\n        if (user.avatar_url) {\n            avatar.innerHTML = `<img src=\"${user.avatar_url}\" alt=\"${user.username}\" class=\"w-full h-full object-cover\">`;\n        }\n        // Add user ID as data attribute\n        const resultItem = resultElement.querySelector('.search-result-item');\n        resultItem.dataset.id = user.id.toString();\n        // Add event listener to send button\n        sendButton.addEventListener('click', () => __awaiter(this, void 0, void 0, function* () {\n            try {\n                // Check if user ID is available\n                if (!user.id) {\n                    console.error('User ID not found');\n                    return;\n                }\n                // Désactiver le bouton pour éviter les clics multiples\n                sendButton.disabled = true;\n                sendButton.classList.add('opacity-50');\n                sendButton.innerHTML = '<span class=\"spinner inline-block w-4 h-4 border-2 border-t-transparent border-white rounded-full animate-spin mr-2\"></span> Envoi...';\n                // Utiliser WebSocket si disponible\n                const websocketService = window.websocketService;\n                if (websocketService && websocketService.isConnected && websocketService.isConnected()) {\n                    console.log('Sending friend request via WebSocket');\n                    websocketService.send('friend-request', { friendId: user.id });\n                    // Remplacer le résultat de recherche par un message de confirmation\n                    resultItem.innerHTML = `\n                        <div class=\"flex items-center justify-between w-full\">\n                            <div class=\"flex items-center\">\n                                <div class=\"result-avatar w-12 h-12 bg-dark-600 rounded-full mr-4 flex items-center justify-center overflow-hidden border border-dark-500\">\n                                    ${avatar.innerHTML}\n                                </div>\n                                <div>\n                                    <p class=\"font-medium text-white\">${user.username}</p>\n                                    <div class=\"flex items-center text-sm\">\n                                        <span class=\"text-green-400\">Demande d'ami envoyée</span>\n                                    </div>\n                                </div>\n                            </div>\n                            <div class=\"animate-pulse\">\n                                <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"h-6 w-6 text-blue-400\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n                                    <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z\" />\n                                </svg>\n                            </div>\n                        </div>\n                    `;\n                    // Après 3 secondes, cacher les résultats de recherche et réinitialiser le formulaire\n                    setTimeout(() => {\n                        searchResultsContainer.classList.add('hidden');\n                        searchUserForm.reset();\n                        // Réinitialisez le résultat après quelques secondes\n                        searchResults.innerHTML = '';\n                    }, 3000);\n                }\n                else {\n                    // Fallback à l'API REST\n                    console.log('WebSocket not available, using REST API');\n                    const response = yield _api__WEBPACK_IMPORTED_MODULE_0__.api.friendship.sendFriendRequest(user.id);\n                    if (response.success) {\n                        // Remplacer le résultat de recherche par un message de confirmation\n                        resultItem.innerHTML = `\n                            <div class=\"flex items-center justify-between w-full\">\n                                <div class=\"flex items-center\">\n                                    <div class=\"result-avatar w-12 h-12 bg-dark-600 rounded-full mr-4 flex items-center justify-center overflow-hidden border border-dark-500\">\n                                        ${avatar.innerHTML}\n                                    </div>\n                                    <div>\n                                        <p class=\"font-medium text-white\">${user.username}</p>\n                                        <div class=\"flex items-center text-sm\">\n                                            <span class=\"text-green-400\">Demande d'ami envoyée</span>\n                                        </div>\n                                    </div>\n                                </div>\n                                <div class=\"animate-pulse\">\n                                    <svg xmlns=\"http://www.w3.org/2000/svg\" class=\"h-6 w-6 text-blue-400\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n                                        <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z\" />\n                                    </svg>\n                                </div>\n                            </div>\n                        `;\n                        // Après 3 secondes, cacher les résultats de recherche et réinitialiser le formulaire\n                        setTimeout(() => {\n                            searchResultsContainer.classList.add('hidden');\n                            searchUserForm.reset();\n                            // Réinitialisez le résultat après quelques secondes\n                            searchResults.innerHTML = '';\n                        }, 3000);\n                    }\n                    else {\n                        console.error('Failed to send friend request:', response.message);\n                        alert(`Erreur: ${response.message}`);\n                        // Réactiver le bouton en cas d'erreur\n                        sendButton.disabled = false;\n                        sendButton.classList.remove('opacity-50');\n                        sendButton.innerHTML = 'Ajouter';\n                    }\n                }\n            }\n            catch (error) {\n                console.error('Error sending friend request:', error);\n                alert('Une erreur est survenue');\n                // Réactiver le bouton en cas d'erreur\n                sendButton.disabled = false;\n                sendButton.classList.remove('opacity-50');\n                sendButton.innerHTML = 'Ajouter';\n            }\n        }));\n        // Add to container\n        searchResults.appendChild(resultElement);\n    }\n    // Event listener for search form submission\n    if (searchUserForm) {\n        searchUserForm.addEventListener('submit', (e) => {\n            e.preventDefault();\n            searchUsers(searchUsername.value);\n        });\n    }\n    // Event listener for friends search input\n    if (friendsSearch) {\n        friendsSearch.addEventListener('input', () => {\n            const query = friendsSearch.value.toLowerCase();\n            const friendItems = friendsContainer.querySelectorAll('.friend-item');\n            friendItems.forEach((item) => {\n                var _a, _b;\n                const username = ((_b = (_a = item.querySelector('.friend-username')) === null || _a === void 0 ? void 0 : _a.textContent) === null || _b === void 0 ? void 0 : _b.toLowerCase()) || '';\n                if (username.includes(query)) {\n                    item.style.display = '';\n                }\n                else {\n                    item.style.display = 'none';\n                }\n            });\n            // Show \"no results\" message if all friends are hidden\n            let allHidden = true;\n            friendItems.forEach((item) => {\n                if (item.style.display !== 'none') {\n                    allHidden = false;\n                }\n            });\n            if (allHidden && friendItems.length > 0) {\n                // Create or update no results message\n                let noResults = document.getElementById('no-search-results');\n                if (!noResults) {\n                    noResults = document.createElement('div');\n                    noResults.id = 'no-search-results';\n                    noResults.className = 'text-center py-4 text-gray-500';\n                    noResults.textContent = `Aucun ami trouvé pour \"${query}\"`;\n                    friendsContainer.appendChild(noResults);\n                }\n                else {\n                    noResults.textContent = `Aucun ami trouvé pour \"${query}\"`;\n                    noResults.classList.remove('hidden');\n                }\n            }\n            else {\n                // Hide no results message if it exists\n                const noResults = document.getElementById('no-search-results');\n                if (noResults) {\n                    noResults.classList.add('hidden');\n                }\n            }\n        });\n    }\n    // Initial data loading\n    function initialize() {\n        return __awaiter(this, void 0, void 0, function* () {\n            console.log('Initializing friends page');\n            try {\n                // Vérifier si auth service est disponible et authentifié\n                if (authService && authService.isAuthenticated && authService.isAuthenticated()) {\n                    console.log('User is authenticated, ensuring token is available for WebSocket');\n                    // S'assurer que le token est disponible\n                    const token = authService.getToken();\n                    console.log('Token availability for WebSocket:', !!token);\n                    if (!token) {\n                        console.error('No token available, auth service getToken returned null');\n                        // Essayer de forcer la restauration de session\n                        authService.restoreSession();\n                        const tokenAfterRestore = authService.getToken();\n                        console.log('Token after forced restore:', !!tokenAfterRestore);\n                        if (!tokenAfterRestore) {\n                            console.error('Still no token after restore, authentication may be invalid');\n                            showNotification('Problème d\\'authentification, veuillez vous reconnecter', 'error');\n                            setTimeout(() => {\n                                window.location.href = '/login.html';\n                            }, 2000);\n                            return;\n                        }\n                    }\n                    // Vérifier l'état de la connexion WebSocket\n                    const websocketService = window.websocketService;\n                    if (websocketService) {\n                        console.log('WebSocket service status on page load:', websocketService.isConnected ?\n                            (websocketService.isConnected() ? 'Connected' : 'Disconnected') :\n                            'Function not available');\n                        // Forcer la connexion WebSocket\n                        console.log('Forcing WebSocket connection on page load');\n                        websocketService.connect();\n                        // Vérifier si la connexion a réussi après un court délai\n                        setTimeout(() => {\n                            console.log('WebSocket connection status after delay:', websocketService.isConnected());\n                            // Si toujours déconnecté après un délai, essayer à nouveau\n                            if (!websocketService.isConnected()) {\n                                console.log('Still disconnected, trying one more time...');\n                                websocketService.connect();\n                                // Vérifier à nouveau après un autre délai\n                                setTimeout(() => {\n                                    const connected = websocketService.isConnected();\n                                    console.log('WebSocket final connection status:', connected);\n                                    if (!connected) {\n                                        console.warn('WebSocket connection failed after multiple attempts');\n                                        console.log('Switching to polling mode for friendship updates');\n                                        showNotification('Mode temps réel indisponible, passage en mode polling', 'info');\n                                    }\n                                }, 1000);\n                            }\n                        }, 1000);\n                    }\n                }\n                // Load friends and friend requests in parallel\n                yield Promise.all([\n                    loadFriends(),\n                    loadFriendRequests()\n                ]);\n                // Configurer un intervalle pour rafraîchir régulièrement les demandes d'amitié\n                // Cela servira de fallback si WebSocket ne fonctionne pas\n                setInterval(() => {\n                    console.log('Refreshing friend requests...');\n                    loadFriendRequests();\n                }, 5000); // Rafraîchir toutes les 5 secondes pour une mise à jour plus rapide\n                console.log('Friends page initialized successfully');\n            }\n            catch (error) {\n                console.error('Error initializing friends page:', error);\n                showNotification('Erreur lors du chargement des données', 'error');\n            }\n        });\n    }\n    // Initialize page\n    initialize();\n}));\n\n\n//# sourceURL=webpack://ft-transcendence-frontend/./src/ts/friends.ts?");

/***/ }),

/***/ "./src/ts/websocket.ts":
/*!*****************************!*\
  !*** ./src/ts/websocket.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   websocketService: () => (/* binding */ websocketService)\n/* harmony export */ });\n// WebSocket URL configuration\nconst WS_URL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'\n    ? 'http://localhost:3000'\n    : window.location.origin; // Use the same origin in production\n// Log the WebSocket URL for debugging\nconsole.log('[Socket.io] Using WebSocket URL:', WS_URL);\n// Constantes partagées avec auth.ts\nconst TOKEN_KEY = 'auth_token';\nclass WebSocketService {\n    constructor() {\n        this.socket = null; // Socket.io socket instead of WebSocket\n        this.listeners = new Map();\n        this.reconnectAttempts = 0;\n        this.maxReconnectAttempts = 3;\n        this.reconnectDelay = 3000;\n        this.isBackendAvailable = true;\n    }\n    // Connect to the Socket.io server\n    connect() {\n        if (this.socket && this.socket.connected) {\n            console.log('[Socket.io] Already connected');\n            return;\n        }\n        if (!this.isBackendAvailable) {\n            console.log('[Socket.io] Backend previously marked as unavailable, skipping connection attempt');\n            return;\n        }\n        // Get token from auth service or storage\n        let token = null;\n        // Try to get token from auth service first\n        const authService = window.authService;\n        if (authService && authService.getToken && typeof authService.getToken === 'function') {\n            token = authService.getToken();\n            console.log('[Socket.io] Got token from authService:', !!token);\n        }\n        // Fallback to localStorage if token not available from auth service\n        if (!token) {\n            token = localStorage.getItem(TOKEN_KEY);\n            console.log('[Socket.io] Got token from localStorage:', !!token);\n        }\n        if (!token) {\n            console.log('[Socket.io] No token available for connection');\n            return;\n        }\n        try {\n            // Close any existing connection\n            this.disconnect();\n            // Import Socket.io client from CDN if not already available\n            if (typeof io === 'undefined') {\n                console.log('[Socket.io] io not defined, loading script from CDN');\n                const script = document.createElement('script');\n                script.src = 'https://cdn.socket.io/4.6.0/socket.io.min.js';\n                script.onload = () => this.initializeSocket(token);\n                document.head.appendChild(script);\n            }\n            else {\n                this.initializeSocket(token);\n            }\n        }\n        catch (error) {\n            console.error('[Socket.io] Setup error:', error);\n            this.attemptReconnect();\n        }\n    }\n    // Initialize Socket.io connection\n    initializeSocket(token) {\n        console.log('[Socket.io] Initializing connection');\n        try {\n            // Log the original token format for debugging\n            console.log('[Socket.io] Original token format:', token.startsWith('Bearer ') ? 'Has Bearer prefix' : 'No Bearer prefix');\n            // Remove Bearer prefix if it exists, to ensure we're not double-prefixing\n            const cleanToken = token.startsWith('Bearer ') ? token.substring(7) : token;\n            const tokenPreview = cleanToken.length > 20\n                ? cleanToken.substring(0, 15) + '...' + cleanToken.substring(cleanToken.length - 5)\n                : cleanToken;\n            console.log('[Socket.io] Token prepared for connection:', tokenPreview);\n            // Connect to Socket.io server with clean token (no Bearer prefix)\n            this.socket = io(WS_URL, {\n                auth: { token: cleanToken },\n                reconnection: true,\n                reconnectionAttempts: this.maxReconnectAttempts,\n                reconnectionDelay: this.reconnectDelay,\n                timeout: 10000\n            });\n            // Connection success\n            this.socket.on('connect', () => {\n                console.log('[Socket.io] Connected successfully');\n                this.reconnectAttempts = 0;\n                this.isBackendAvailable = true;\n                this.reattachListeners();\n            });\n            // Connection error\n            this.socket.on('connect_error', (error) => {\n                console.error('[Socket.io] Connection error:', error);\n                this.reconnectAttempts++;\n                if (this.reconnectAttempts > this.maxReconnectAttempts) {\n                    console.log('[Socket.io] Max reconnect attempts reached, giving up');\n                    this.isBackendAvailable = false;\n                    this.socket.disconnect();\n                }\n            });\n            // Handle disconnect\n            this.socket.on('disconnect', (reason) => {\n                console.log(`[Socket.io] Disconnected: ${reason}`);\n            });\n            // Handle errors from server\n            this.socket.on('error', (data) => {\n                console.error('[Socket.io] Error from server:', data);\n                if (data && data.message) {\n                    alert(`Erreur: ${data.message}`);\n                }\n            });\n            // Setup handlers for standard events we're interested in\n            ['friend-request-received', 'friend-request-sent', 'friend-request-accepted',\n                'friend-request-rejected', 'friend-removed', 'friend-status-change',\n                'game-invitation', 'game-started'].forEach(event => {\n                this.socket.on(event, (data) => {\n                    var _a;\n                    console.log(`[Socket.io] Received ${event} event:`, data);\n                    // Add type field if not present\n                    if (!data.type) {\n                        data.type = event;\n                    }\n                    // Forward to our listeners\n                    if (this.listeners.has(event)) {\n                        (_a = this.listeners.get(event)) === null || _a === void 0 ? void 0 : _a.forEach(callback => callback(data));\n                    }\n                });\n            });\n        }\n        catch (error) {\n            console.error('[Socket.io] Initialization error:', error);\n            this.attemptReconnect();\n        }\n    }\n    // Disconnect from the Socket.io server\n    disconnect() {\n        if (this.socket) {\n            console.log('[Socket.io] Disconnecting');\n            this.socket.disconnect();\n            this.socket = null;\n        }\n        this.reconnectAttempts = 0;\n    }\n    // Subscribe to an event\n    on(event, callback) {\n        var _a;\n        console.log(`[Socket.io] Registering event handler for: ${event}`);\n        if (!this.listeners.has(event)) {\n            this.listeners.set(event, new Set());\n        }\n        (_a = this.listeners.get(event)) === null || _a === void 0 ? void 0 : _a.add(callback);\n        // If already connected, register with socket.io server\n        if (this.socket && this.socket.connected) {\n            console.log(`[Socket.io] Already connected, subscribing to ${event}`);\n            this.socket.on(event, (data) => {\n                console.log(`[Socket.io] Direct event ${event}:`, data);\n                // Add type if missing\n                if (!data.type) {\n                    data.type = event;\n                }\n                callback(data);\n            });\n        }\n    }\n    // Unsubscribe from an event\n    off(event, callback) {\n        const listeners = this.listeners.get(event);\n        if (listeners) {\n            listeners.delete(callback);\n            if (listeners.size === 0) {\n                this.listeners.delete(event);\n                // If connected, remove listener from socket.io\n                if (this.socket && this.socket.connected) {\n                    this.socket.off(event);\n                }\n            }\n        }\n    }\n    // Send a message to the server\n    send(type, data) {\n        if (!this.socket || !this.socket.connected) {\n            console.warn('[Socket.io] Cannot send message: not connected');\n            return false;\n        }\n        try {\n            console.log(`[Socket.io] Emitting ${type}:`, data);\n            this.socket.emit(type, data);\n            return true;\n        }\n        catch (error) {\n            console.error('[Socket.io] Error sending message:', error);\n            return false;\n        }\n    }\n    // Check if connected\n    isConnected() {\n        var _a;\n        console.log('[Socket.io] Checking connection status:', ((_a = this.socket) === null || _a === void 0 ? void 0 : _a.connected) || false);\n        return this.socket && this.socket.connected;\n    }\n    // Reattach all event listeners after reconnect\n    reattachListeners() {\n        if (!this.socket || !this.socket.connected)\n            return;\n        console.log('[Socket.io] Reattaching event listeners');\n        this.listeners.forEach((callbacks, event) => {\n            console.log(`[Socket.io] Resubscribing to event: ${event}`);\n            this.socket.on(event, (data) => {\n                console.log(`[Socket.io] Received reattached ${event}:`, data);\n                // Add type if missing\n                if (!data.type) {\n                    data.type = event;\n                }\n                callbacks.forEach(callback => callback(data));\n            });\n        });\n    }\n    // Attempt to reconnect\n    attemptReconnect() {\n        this.reconnectAttempts++;\n        if (this.reconnectAttempts > this.maxReconnectAttempts) {\n            console.log('[Socket.io] Max reconnect attempts reached, giving up');\n            this.isBackendAvailable = false;\n            return;\n        }\n        const delay = Math.min(10000, this.reconnectDelay * Math.pow(1.5, this.reconnectAttempts - 1));\n        console.log(`[Socket.io] Attempting to reconnect in ${delay}ms (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\n        setTimeout(() => {\n            this.connect();\n        }, delay);\n    }\n}\n// Create a singleton instance\nconst websocketService = new WebSocketService();\n// Export the websocket service\n\n// Make it globally available\nwindow.websocketService = websocketService;\n// Auto-connect if user is authenticated\ndocument.addEventListener('DOMContentLoaded', () => {\n    const token = localStorage.getItem('auth_token');\n    if (token) {\n        console.log('[Socket.io] Auto-connecting...');\n        websocketService.connect();\n    }\n});\n\n\n//# sourceURL=webpack://ft-transcendence-frontend/./src/ts/websocket.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/ts/friends.ts");
/******/ 	
/******/ })()
;