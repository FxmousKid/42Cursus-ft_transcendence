/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/ts/api.ts":
/*!***********************!*\
  !*** ./src/ts/api.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   api: () => (/* binding */ api),\n/* harmony export */   getAvatarUrl: () => (/* binding */ getAvatarUrl)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// API URL configuration\n// Force localhost:3000 for debugging\nconst API_URL = 'http://localhost:3000';\n// Debug logging to help identify the issue\nconsole.log('[API] Debug - Forced API_URL to:', API_URL);\nconsole.log('[API] Debug - window.location.hostname:', window.location.hostname);\nconsole.log('[API] Debug - window.location.origin:', window.location.origin);\n// Helper for API requests\nfunction request(endpoint_1) {\n    return __awaiter(this, arguments, void 0, function* (endpoint, options = {}) {\n        try {\n            const url = `${API_URL}${endpoint}`;\n            console.log(`[API] Making ${options.method || 'GET'} request to: ${url}`);\n            // Get the most up-to-date token\n            const authService = window.authService;\n            let token;\n            if (authService && authService.getToken) {\n                // Get the token directly from auth service if available\n                token = authService.getToken();\n                console.log(`[API] Got token from authService: ${!!token}`);\n            }\n            else {\n                // Fallback to localStorage\n                token = localStorage.getItem('auth_token');\n                console.log(`[API] Got token from localStorage: ${!!token}`);\n            }\n            // Prepare headers - don't set Content-Type for FormData\n            const headers = Object.assign({ 'Accept': 'application/json' }, (token && { 'Authorization': `Bearer ${token}` }));\n            // Only set Content-Type if not FormData\n            if (!(options.body instanceof FormData)) {\n                headers['Content-Type'] = 'application/json';\n            }\n            // Add custom headers\n            Object.assign(headers, options.headers || {});\n            // Add a timeout to the fetch request\n            const controller = new AbortController();\n            const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout\n            const response = yield fetch(url, Object.assign(Object.assign({}, options), { headers, mode: 'cors', credentials: 'include', signal: controller.signal }));\n            clearTimeout(timeoutId); // Clear the timeout\n            console.log(`[API] Response status: ${response.status}`);\n            // Handle authentication errors\n            if (response.status === 401) {\n                console.log('[API] Authentication error (401) received');\n                // Use the auth service to clear the session if available\n                if (authService && authService.clearSession) {\n                    console.log('[API] Using authService to clear session');\n                    authService.clearSession();\n                }\n                else {\n                    // Fallback manual cleanup\n                    console.log('[API] Manually clearing auth data from storage');\n                    localStorage.removeItem('auth_token');\n                    localStorage.removeItem('user_id');\n                    localStorage.removeItem('username');\n                    localStorage.removeItem('avatar_url');\n                    sessionStorage.removeItem('auth_token');\n                    sessionStorage.removeItem('user_id');\n                    sessionStorage.removeItem('username');\n                    sessionStorage.removeItem('avatar_url');\n                }\n                // Get the current path and check if we need to redirect\n                const currentPath = window.location.pathname;\n                // Don't redirect if already on login page to avoid redirect loop\n                if (!currentPath.includes('login') && !currentPath.includes('register')) {\n                    console.log('[API] Redirecting to login page due to 401 error');\n                    window.location.href = '/login.html';\n                }\n                else {\n                    console.log('[API] Already on login/register page, not redirecting');\n                }\n                return {\n                    success: false,\n                    message: 'Authentication required'\n                };\n            }\n            // Handle 404 errors\n            if (response.status === 404) {\n                console.warn(`[API] Endpoint not found: ${endpoint}`);\n                return {\n                    success: false,\n                    message: `Endpoint not found: ${endpoint}`,\n                    data: [] // Renvoyer un tableau vide par défaut\n                };\n            }\n            // Handle no content response\n            if (response.status === 204) {\n                return { success: true };\n            }\n            let data;\n            try {\n                const text = yield response.text();\n                data = text ? JSON.parse(text) : {};\n            }\n            catch (error) {\n                console.error('Error parsing response:', error);\n                return {\n                    success: false,\n                    message: 'Failed to parse server response'\n                };\n            }\n            if (!response.ok) {\n                return {\n                    success: false,\n                    message: data.message || 'An error occurred'\n                };\n            }\n            return data;\n        }\n        catch (error) {\n            console.error('API request failed:', error);\n            if (error instanceof TypeError && error.message === 'Failed to fetch') {\n                console.warn('[API] Failed to fetch. The backend server may be down or unreachable.');\n                // Show a user-friendly message in the console that could be displayed to the user\n                console.log('[API] Connection to server failed. Please check if the backend is running.');\n            }\n            return {\n                success: false,\n                message: error instanceof Error ? error.message : 'Unknown error',\n                data: [] // Return an empty array by default\n            };\n        }\n    });\n}\n// Helper function to get avatar URL\nfunction getAvatarUrl(user) {\n    // Prioritize uploaded avatar data over URL\n    if (user.has_avatar_data) {\n        return `${API_URL}/users/avatar/${user.id}`;\n    }\n    // Fall back to avatar URL if available\n    if (user.avatar_url) {\n        return user.avatar_url;\n    }\n    // Return empty string - let the UI handle the default\n    return '';\n}\n// Create and export API object\nconst api = {\n    baseUrl: API_URL,\n    // Auth services\n    auth: {\n        login(email, password) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/auth/login', {\n                    method: 'POST',\n                    body: JSON.stringify({ email, password })\n                });\n            });\n        },\n        register(username, email, password) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/auth/register', {\n                    method: 'POST',\n                    body: JSON.stringify({ username, email, password })\n                });\n            });\n        },\n        logout() {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/auth/logout', {\n                    method: 'POST'\n                });\n            });\n        }\n    },\n    // User services\n    user: {\n        getProfile() {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/users/profile'); // Use /users/profile instead of /users/${id}\n            });\n        },\n        updateProfile(data) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/users/profile', {\n                    method: 'PUT', // Use PUT instead of PATCH to match backend\n                    body: JSON.stringify(data)\n                });\n            });\n        },\n        deleteProfile() {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/users/profile', {\n                    method: 'DELETE'\n                });\n            });\n        },\n        getMatches() {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/users/matches');\n            });\n        },\n        getAll() {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/users');\n            });\n        },\n        searchUsers(username) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request(`/users/search?username=${encodeURIComponent(username)}`);\n            });\n        },\n        checkUsername(username) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request(`/users/check-username?username=${encodeURIComponent(username)}`);\n            });\n        },\n        // New avatar methods\n        uploadAvatar(file) {\n            return __awaiter(this, void 0, void 0, function* () {\n                const formData = new FormData();\n                formData.append('file', file);\n                return request('/users/profile/avatar', {\n                    method: 'POST',\n                    body: formData\n                });\n            });\n        },\n        deleteAvatar() {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/users/profile/avatar', {\n                    method: 'DELETE'\n                });\n            });\n        }\n    },\n    // Friendship services\n    friendship: {\n        getFriends() {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/friendships');\n            });\n        },\n        getPendingRequests() {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/friendships/requests');\n            });\n        },\n        sendFriendRequest(friendId) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/friendships/request', {\n                    method: 'POST',\n                    body: JSON.stringify({ friend_id: friendId })\n                });\n            });\n        },\n        acceptFriendRequest(requestId) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request(`/friendships/accept/${requestId}`, {\n                    method: 'POST',\n                    body: JSON.stringify({})\n                });\n            });\n        },\n        rejectFriendRequest(requestId) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request(`/friendships/reject/${requestId}`, {\n                    method: 'POST',\n                    body: JSON.stringify({})\n                });\n            });\n        },\n        removeFriend(friendId) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request(`/friendships/${friendId}`, {\n                    method: 'DELETE'\n                });\n            });\n        }\n    },\n    // Game services\n    game: {\n        getAllMatches() {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/game/matches');\n            });\n        }\n    },\n    // Chat services\n    chat: {\n        getMessages(userId) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request(`/chat/messages/${userId}`);\n            });\n        },\n        getUnreadCount() {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/chat/unread');\n            });\n        },\n        blockUser(userId) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/chat/block', {\n                    method: 'POST',\n                    body: JSON.stringify({ blocked_id: userId })\n                });\n            });\n        },\n        unblockUser(userId) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request(`/chat/block/${userId}`, {\n                    method: 'DELETE'\n                });\n            });\n        },\n        getBlockedUsers() {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/chat/blocks');\n            });\n        }\n    }\n};\n// Pour la rétrocompatibilité, on expose aussi API globalement\nif (typeof window !== 'undefined') {\n    window.api = api;\n    window.getAvatarUrl = getAvatarUrl;\n}\n\n\n//# sourceURL=webpack://ft-transcendence-frontend/./src/ts/api.ts?");

/***/ }),

/***/ "./src/ts/profile.ts":
/*!***************************!*\
  !*** ./src/ts/profile.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api */ \"./src/ts/api.ts\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n/**\n * Script pour gérer la page de profil\n */\n// Utility function to create avatar HTML with consistent styling\nfunction createAvatarHTML(user, size = 'large') {\n    const sizeClasses = {\n        small: 'w-8 h-8',\n        medium: 'w-12 h-12',\n        large: 'w-32 h-32'\n    };\n    const iconSizes = {\n        small: 'text-lg',\n        medium: 'text-xl',\n        large: 'text-5xl'\n    };\n    const sizeClass = sizeClasses[size];\n    const iconSize = iconSizes[size];\n    // Use getAvatarUrl to prioritize uploaded avatars over URLs\n    let avatarUrl = '';\n    if (user.id) {\n        avatarUrl = (0,_api__WEBPACK_IMPORTED_MODULE_0__.getAvatarUrl)({\n            id: user.id,\n            has_avatar_data: user.has_avatar_data,\n            avatar_url: user.avatar_url || undefined\n        });\n    }\n    if (avatarUrl && avatarUrl.trim()) {\n        // Add cache-busting parameter to force reload of uploaded avatars\n        const finalAvatarUrl = user.has_avatar_data ?\n            `${avatarUrl}?t=${Date.now()}` : avatarUrl;\n        return `<img src=\"${finalAvatarUrl}\" alt=\"${user.username}\" class=\"w-full h-full object-cover\" onerror=\"this.style.display='none'; this.nextElementSibling.style.display='flex';\">\n                <i class=\"fas fa-user text-white ${iconSize}\" style=\"display: none;\"></i>`;\n    }\n    else {\n        return `<i class=\"fas fa-user text-white ${iconSize}\"></i>`;\n    }\n}\ndocument.addEventListener('DOMContentLoaded', () => {\n    console.log('Profile page loaded');\n    // Obtenir l'instance du service d'authentification\n    const authService = window.authService;\n    console.log('Auth service available:', !!authService);\n    // Vérifier l'état d'authentification\n    const isAuthenticated = authService && authService.isAuthenticated && authService.isAuthenticated();\n    console.log('User is authenticated:', isAuthenticated);\n    if (!isAuthenticated) {\n        console.log('User is not authenticated, should be redirected by route-guard.js');\n        return;\n    }\n    // Obtenir l'instance de l'API\n    const api = window.api;\n    const getAvatarUrl = window.getAvatarUrl;\n    if (!api || !api.user) {\n        console.error('API not available');\n        return;\n    }\n    // Profile elements\n    const profileUsernameElement = document.getElementById('profile-username');\n    const profileEmail = document.getElementById('profile-email');\n    const profileStatus = document.getElementById('profile-status');\n    const profileAvatar = document.getElementById('profile-avatar');\n    const avatarUploadInput = document.getElementById('avatar-upload-input');\n    const removeAvatarBtn = document.getElementById('remove-avatar-btn');\n    // Stats elements\n    const statsGamesPlayed = document.getElementById('stats-games-played');\n    const statsWins = document.getElementById('stats-wins');\n    const statsLosses = document.getElementById('stats-losses');\n    const statsRatio = document.getElementById('stats-ratio');\n    // Matches elements\n    const matchesContainer = document.getElementById('matches-container');\n    const noMatches = document.getElementById('no-matches');\n    const matchTemplate = document.getElementById('match-template');\n    // Edit profile elements\n    const editProfileButton = document.getElementById('edit-profile-button');\n    const editProfileModal = document.getElementById('edit-profile-modal');\n    const editProfileForm = document.getElementById('edit-profile-form');\n    const editUsername = document.getElementById('edit-username');\n    const editEmail = document.getElementById('edit-email');\n    const editAvatar = document.getElementById('edit-avatar');\n    const cancelEditButton = document.getElementById('cancel-edit');\n    const editErrorMessage = document.getElementById('edit-error-message');\n    const editErrorText = document.getElementById('edit-error-text');\n    // Delete account elements\n    const deleteAccountButton = document.getElementById('delete-account-button');\n    const deleteAccountModal = document.getElementById('delete-account-modal');\n    const confirmDeleteButton = document.getElementById('confirm-delete');\n    const cancelDeleteButton = document.getElementById('cancel-delete');\n    const deleteErrorMessage = document.getElementById('delete-error-message');\n    const deleteErrorText = document.getElementById('delete-error-text');\n    // Current user data\n    let currentUserData = null;\n    // Initially hide the remove button until we confirm there's an avatar\n    if (removeAvatarBtn) {\n        removeAvatarBtn.classList.add('hidden');\n    }\n    // Utiliser les données du localStorage pour afficher des informations de base\n    const username = localStorage.getItem('username');\n    const email = localStorage.getItem('email') || '';\n    const avatarUrl = localStorage.getItem('avatar_url');\n    const userId = localStorage.getItem('userId') || localStorage.getItem('user_id');\n    // Afficher les informations de base depuis localStorage\n    if (username) {\n        profileUsernameElement.textContent = username;\n        if (profileStatus) {\n            profileStatus.textContent = 'offline';\n            profileStatus.classList.add('text-gray-600');\n        }\n        // Pré-remplir les champs du formulaire\n        if (editUsername)\n            editUsername.value = username;\n        if (editEmail)\n            editEmail.value = email;\n        if (editAvatar)\n            editAvatar.value = avatarUrl || '';\n        // Afficher l'avatar si disponible et userId est défini\n        if (avatarUrl && avatarUrl.trim() !== '' && userId) {\n            updateAvatarDisplay({ id: parseInt(userId), avatar_url: avatarUrl, has_avatar_data: false });\n        }\n    }\n    // Charger les données complètes du profil\n    loadProfileData();\n    // Charger les matchs\n    loadMatches();\n    // EVENT LISTENERS SIMPLIFIÉS\n    // Clic sur l'avatar pour choisir une nouvelle photo\n    if (profileAvatar && avatarUploadInput) {\n        profileAvatar.addEventListener('click', (e) => {\n            console.log('Avatar clicked!');\n            e.preventDefault();\n            e.stopPropagation();\n            try {\n                avatarUploadInput.click();\n            }\n            catch (error) {\n                console.error('Error triggering file input:', error);\n            }\n        });\n    }\n    else {\n        console.warn('Profile avatar or upload input not found');\n    }\n    // Bouton supprimer avatar\n    if (removeAvatarBtn) {\n        removeAvatarBtn.addEventListener('click', (e) => {\n            console.log('Remove button clicked!');\n            e.preventDefault();\n            e.stopPropagation();\n            handleRemoveAvatar();\n        });\n    }\n    // Handle avatar upload\n    if (avatarUploadInput) {\n        avatarUploadInput.addEventListener('change', handleAvatarUpload);\n    }\n    // Gérer le bouton d'édition de profil\n    if (editProfileButton && editProfileModal) {\n        editProfileButton.addEventListener('click', () => {\n            editProfileModal.classList.remove('hidden');\n        });\n    }\n    if (cancelEditButton && editProfileModal) {\n        cancelEditButton.addEventListener('click', () => {\n            editProfileModal.classList.add('hidden');\n            if (editErrorMessage) {\n                editErrorMessage.classList.add('hidden');\n            }\n        });\n    }\n    if (editProfileForm) {\n        editProfileForm.addEventListener('submit', (e) => {\n            e.preventDefault();\n            submitProfileEdit();\n        });\n    }\n    // Gérer le bouton de suppression de compte\n    if (deleteAccountButton && deleteAccountModal) {\n        deleteAccountButton.addEventListener('click', () => {\n            deleteAccountModal.classList.remove('hidden');\n        });\n    }\n    if (cancelDeleteButton && deleteAccountModal) {\n        cancelDeleteButton.addEventListener('click', () => {\n            deleteAccountModal.classList.add('hidden');\n            if (deleteErrorMessage) {\n                deleteErrorMessage.classList.add('hidden');\n            }\n        });\n    }\n    if (confirmDeleteButton) {\n        confirmDeleteButton.addEventListener('click', () => {\n            deleteAccount();\n        });\n    }\n    // Fonction pour mettre à jour l'affichage de l'avatar\n    function updateAvatarDisplay(userData) {\n        if (!profileAvatar) {\n            console.warn('Profile avatar element not found');\n            return;\n        }\n        try {\n            const avatarUrl = getAvatarUrl ? getAvatarUrl(userData) : '';\n            if (avatarUrl) {\n                // Add cache-busting parameter to force reload of uploaded avatars\n                const finalAvatarUrl = userData.has_avatar_data ?\n                    `${avatarUrl}?t=${Date.now()}` : avatarUrl;\n                // When there's an avatar, show the image and hide the default icon\n                profileAvatar.innerHTML = `\n                    <img src=\"${finalAvatarUrl}\" alt=\"${userData.username || username}\" class=\"w-full h-full object-cover\" onerror=\"this.style.display='none'; this.nextElementSibling.style.display='flex';\">\n                    <i class=\"fas fa-user text-white text-5xl\" style=\"display: none;\"></i>\n                `;\n            }\n            else {\n                // When there's no avatar, show only the default icon - the container keeps its gradient background\n                profileAvatar.innerHTML = `<i class=\"fas fa-user text-white text-5xl\"></i>`;\n            }\n            // Show/hide remove button based on whether user has uploaded avatar or avatar_url\n            if (removeAvatarBtn) {\n                // Only show remove button if there's actually an avatar to remove\n                // This means either uploaded avatar data OR a valid avatar_url that produces an image\n                const hasUploadedAvatar = userData.has_avatar_data;\n                const hasValidAvatarUrl = userData.avatar_url && userData.avatar_url.trim() !== '';\n                if (hasUploadedAvatar || hasValidAvatarUrl) {\n                    removeAvatarBtn.classList.remove('hidden');\n                }\n                else {\n                    removeAvatarBtn.classList.add('hidden');\n                }\n            }\n        }\n        catch (error) {\n            console.error('Error updating avatar display:', error);\n        }\n    }\n    // Fonction pour gérer l'upload d'avatar\n    function handleAvatarUpload(event) {\n        return __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            const input = event.target;\n            const file = (_a = input.files) === null || _a === void 0 ? void 0 : _a[0];\n            if (!file)\n                return;\n            // Validate file type\n            const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];\n            if (!allowedTypes.includes(file.type)) {\n                console.error('Type de fichier non supporté. Utilisez JPEG, PNG, GIF ou WebP.');\n                return;\n            }\n            // Validate file size (2MB)\n            if (file.size > 2 * 1024 * 1024) {\n                console.error('Le fichier est trop volumineux. Taille maximale: 2MB.');\n                return;\n            }\n            console.log('Téléchargement en cours...');\n            try {\n                const response = yield api.user.uploadAvatar(file);\n                if (response.success) {\n                    console.log('Avatar uploadé avec succès');\n                    // Reload profile data to get updated avatar info\n                    yield loadProfileData();\n                }\n                else {\n                    console.error('Erreur lors du téléchargement:', response.message);\n                }\n            }\n            catch (error) {\n                console.error('Error uploading avatar:', error);\n            }\n            // Clear the input\n            input.value = '';\n        });\n    }\n    // Fonction pour supprimer l'avatar\n    function handleRemoveAvatar() {\n        return __awaiter(this, void 0, void 0, function* () {\n            console.log('Suppression en cours...');\n            try {\n                const response = yield api.user.deleteAvatar();\n                if (response.success) {\n                    console.log('Avatar supprimé avec succès');\n                    // Reload profile data\n                    yield loadProfileData();\n                }\n                else {\n                    console.error('Erreur lors de la suppression:', response.message);\n                }\n            }\n            catch (error) {\n                console.error('Error removing avatar:', error);\n            }\n        });\n    }\n    // Fonction asynchrone pour charger les données du profil\n    function loadProfileData() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                console.log('Loading full profile data from API');\n                const response = yield api.user.getProfile();\n                console.log('Profile API response:', response);\n                if (response.success && response.data) {\n                    console.log('Successfully loaded profile data');\n                    const profile = response.data;\n                    currentUserData = profile;\n                    // Afficher les informations du profil\n                    profileUsernameElement.textContent = profile.username;\n                    if (profileEmail) {\n                        profileEmail.textContent = profile.email || '';\n                    }\n                    // Update avatar display using the unified function\n                    updateAvatarDisplay(profile);\n                    // Définir les valeurs du formulaire pour l'édition\n                    if (editUsername)\n                        editUsername.value = profile.username;\n                    if (editEmail)\n                        editEmail.value = profile.email || '';\n                    if (editAvatar)\n                        editAvatar.value = profile.avatar_url || '';\n                    // Stocker l'email dans localStorage pour une utilisation future\n                    if (profile.email) {\n                        localStorage.setItem('email', profile.email);\n                    }\n                    // Stocker l'URL de l'avatar dans localStorage si disponible\n                    if (profile.avatar_url) {\n                        localStorage.setItem('avatar_url', profile.avatar_url);\n                    }\n                }\n                else {\n                    console.error('Failed to load profile data:', response.message);\n                }\n            }\n            catch (error) {\n                console.error('Error loading profile data:', error);\n            }\n        });\n    }\n    function loadMatches() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const matchesResponse = yield api.user.getMatches();\n                if (matchesResponse.success && matchesResponse.data && matchesResponse.data.length > 0) {\n                    const matches = matchesResponse.data;\n                    // Hide \"no matches\" message\n                    if (noMatches) {\n                        noMatches.classList.add('hidden');\n                    }\n                    // Calculate stats\n                    let wins = 0;\n                    let losses = 0;\n                    const userId = authService.getUserId();\n                    // Clear existing matches\n                    if (matchesContainer) {\n                        matchesContainer.innerHTML = '';\n                    }\n                    // Display matches\n                    if (matchesContainer && matchTemplate) {\n                        matches.forEach((match) => {\n                            // Determine if current user is player1 or player2\n                            const isPlayer1 = match.player1_id.toString() === userId;\n                            const currentPlayerScore = isPlayer1 ? match.player1_score : match.player2_score;\n                            const opponentScore = isPlayer1 ? match.player2_score : match.player1_score;\n                            const opponentUsername = isPlayer1 ? match.player2_username : match.player1_username;\n                            // Determine if match was won or lost\n                            const isWin = currentPlayerScore > opponentScore;\n                            if (isWin)\n                                wins++;\n                            else\n                                losses++;\n                            // Create match element from template\n                            const matchElement = document.importNode(matchTemplate.content, true);\n                            // Set match details\n                            const resultIndicator = matchElement.querySelector('.match-result-indicator');\n                            const opponent = matchElement.querySelector('.match-opponent');\n                            const date = matchElement.querySelector('.match-date');\n                            const score = matchElement.querySelector('.match-score');\n                            if (resultIndicator) {\n                                resultIndicator.classList.add(isWin ? 'bg-green-500' : 'bg-red-500');\n                            }\n                            if (opponent)\n                                opponent.textContent = opponentUsername || 'Unknown';\n                            if (score)\n                                score.textContent = `${currentPlayerScore} - ${opponentScore}`;\n                            // Format date\n                            if (date && match.created_at) {\n                                const matchDate = new Date(match.created_at);\n                                date.textContent = matchDate.toLocaleDateString();\n                            }\n                            // Add match to container\n                            matchesContainer.appendChild(matchElement);\n                        });\n                    }\n                    // Update stats\n                    const total = wins + losses;\n                    if (statsGamesPlayed)\n                        statsGamesPlayed.textContent = total.toString();\n                    if (statsWins)\n                        statsWins.textContent = wins.toString();\n                    if (statsLosses)\n                        statsLosses.textContent = losses.toString();\n                    if (statsRatio)\n                        statsRatio.textContent = total > 0 ? (wins / total).toFixed(2) : '0.00';\n                }\n                else {\n                    // Show \"no matches\" message if no matches found\n                    if (noMatches) {\n                        noMatches.classList.remove('hidden');\n                    }\n                }\n            }\n            catch (error) {\n                console.error('Error loading matches:', error);\n                // Show \"no matches\" message in case of error\n                if (noMatches) {\n                    noMatches.classList.remove('hidden');\n                }\n            }\n        });\n    }\n    // Fonction pour soumettre les modifications du profil\n    function submitProfileEdit() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!editUsername || !editEmail)\n                return;\n            const updateData = {\n                username: editUsername.value,\n                email: editEmail.value,\n                avatar_url: editAvatar ? editAvatar.value : undefined\n            };\n            try {\n                const response = yield api.user.updateProfile(updateData);\n                if (response.success) {\n                    // Mettre à jour le nom d'utilisateur dans localStorage\n                    if (updateData.username) {\n                        localStorage.setItem('username', updateData.username);\n                        // Mettre à jour l'état dans authService\n                        if (authService && typeof authService.updateUsername === 'function') {\n                            authService.updateUsername(updateData.username);\n                        }\n                    }\n                    // Mettre à jour l'avatar dans localStorage si nécessaire\n                    if (updateData.avatar_url) {\n                        localStorage.setItem('avatar_url', updateData.avatar_url);\n                    }\n                    // Fermer le modal\n                    if (editProfileModal) {\n                        editProfileModal.classList.add('hidden');\n                    }\n                    // Recharger les données du profil\n                    loadProfileData();\n                    // Recharger le header pour refléter les changements\n                    window.location.reload();\n                }\n                else {\n                    // Afficher l'erreur\n                    if (editErrorMessage && editErrorText) {\n                        editErrorText.textContent = response.message || 'Une erreur est survenue';\n                        editErrorMessage.classList.remove('hidden');\n                    }\n                }\n            }\n            catch (error) {\n                console.error('Error updating profile:', error);\n                if (editErrorMessage && editErrorText) {\n                    editErrorText.textContent = 'Erreur de connexion au serveur';\n                    editErrorMessage.classList.remove('hidden');\n                }\n            }\n        });\n    }\n    // Fonction pour supprimer le compte utilisateur\n    function deleteAccount() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                // Montrer l'état de chargement sur le bouton\n                if (confirmDeleteButton) {\n                    confirmDeleteButton.textContent = 'Suppression en cours...';\n                    confirmDeleteButton.disabled = true;\n                }\n                const response = yield api.user.deleteProfile();\n                if (response.success) {\n                    // Déconnexion et redirection vers la page de login\n                    yield authService.logout();\n                    window.location.href = '/login.html';\n                }\n                else {\n                    // Afficher l'erreur\n                    if (deleteErrorMessage && deleteErrorText) {\n                        deleteErrorText.textContent = response.message || 'Une erreur est survenue lors de la suppression du compte';\n                        deleteErrorMessage.classList.remove('hidden');\n                    }\n                    // Réinitialiser le bouton\n                    if (confirmDeleteButton) {\n                        confirmDeleteButton.textContent = 'Confirmer la suppression';\n                        confirmDeleteButton.disabled = false;\n                    }\n                }\n            }\n            catch (error) {\n                console.error('Error deleting account:', error);\n                if (deleteErrorMessage && deleteErrorText) {\n                    deleteErrorText.textContent = 'Erreur de connexion au serveur';\n                    deleteErrorMessage.classList.remove('hidden');\n                }\n                // Réinitialiser le bouton\n                if (confirmDeleteButton) {\n                    confirmDeleteButton.textContent = 'Confirmer la suppression';\n                    confirmDeleteButton.disabled = false;\n                }\n            }\n        });\n    }\n});\n\n\n//# sourceURL=webpack://ft-transcendence-frontend/./src/ts/profile.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/ts/profile.ts");
/******/ 	
/******/ })()
;