/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/ts/websocket.ts":
/*!*****************************!*\
  !*** ./src/ts/websocket.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   websocketService: () => (/* binding */ websocketService)\n/* harmony export */ });\n// WebSocket URL configuration\nconst WS_URL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'\n    ? 'http://localhost:3000'\n    : window.location.origin; // Use the same origin in production\n// Log the WebSocket URL for debugging\nconsole.log('[Socket.io] Using WebSocket URL:', WS_URL);\n// Constantes partagÃ©es avec auth.ts\nconst TOKEN_KEY = 'auth_token';\nclass WebSocketService {\n    constructor() {\n        this.socket = null; // Socket.io socket instead of WebSocket\n        this.listeners = new Map();\n        this.reconnectAttempts = 0;\n        this.maxReconnectAttempts = 3;\n        this.reconnectDelay = 3000;\n        this.isBackendAvailable = true;\n    }\n    // Connect to the Socket.io server\n    connect() {\n        if (this.socket && this.socket.connected) {\n            console.log('[Socket.io] Already connected');\n            return;\n        }\n        if (!this.isBackendAvailable) {\n            console.log('[Socket.io] Backend previously marked as unavailable, skipping connection attempt');\n            return;\n        }\n        // Get token from auth service or storage\n        let token = null;\n        // Try to get token from auth service first\n        const authService = window.authService;\n        if (authService && authService.getToken && typeof authService.getToken === 'function') {\n            token = authService.getToken();\n            console.log('[Socket.io] Got token from authService:', !!token);\n        }\n        // Fallback to localStorage if token not available from auth service\n        if (!token) {\n            token = localStorage.getItem(TOKEN_KEY);\n            console.log('[Socket.io] Got token from localStorage:', !!token);\n        }\n        if (!token) {\n            console.log('[Socket.io] No token available for connection');\n            return;\n        }\n        try {\n            // Close any existing connection\n            this.disconnect();\n            // Import Socket.io client from CDN if not already available\n            if (typeof io === 'undefined') {\n                console.log('[Socket.io] io not defined, loading script from CDN');\n                const script = document.createElement('script');\n                script.src = 'https://cdn.socket.io/4.6.0/socket.io.min.js';\n                script.onload = () => this.initializeSocket(token);\n                document.head.appendChild(script);\n            }\n            else {\n                this.initializeSocket(token);\n            }\n        }\n        catch (error) {\n            console.error('[Socket.io] Setup error:', error);\n            this.attemptReconnect();\n        }\n    }\n    // Initialize Socket.io connection\n    initializeSocket(token) {\n        console.log('[Socket.io] Initializing connection');\n        try {\n            // Log the original token format for debugging\n            console.log('[Socket.io] Original token format:', token.startsWith('Bearer ') ? 'Has Bearer prefix' : 'No Bearer prefix');\n            // Remove Bearer prefix if it exists, to ensure we're not double-prefixing\n            const cleanToken = token.startsWith('Bearer ') ? token.substring(7) : token;\n            const tokenPreview = cleanToken.length > 20\n                ? cleanToken.substring(0, 15) + '...' + cleanToken.substring(cleanToken.length - 5)\n                : cleanToken;\n            console.log('[Socket.io] Token prepared for connection:', tokenPreview);\n            // Connect to Socket.io server with clean token (no Bearer prefix)\n            this.socket = io(WS_URL, {\n                auth: { token: cleanToken },\n                reconnection: true,\n                reconnectionAttempts: this.maxReconnectAttempts,\n                reconnectionDelay: this.reconnectDelay,\n                timeout: 10000\n            });\n            // Connection success\n            this.socket.on('connect', () => {\n                console.log('[Socket.io] Connected successfully');\n                this.reconnectAttempts = 0;\n                this.isBackendAvailable = true;\n                this.reattachListeners();\n            });\n            // Connection error\n            this.socket.on('connect_error', (error) => {\n                console.error('[Socket.io] Connection error:', error);\n                this.reconnectAttempts++;\n                if (this.reconnectAttempts > this.maxReconnectAttempts) {\n                    console.log('[Socket.io] Max reconnect attempts reached, giving up');\n                    this.isBackendAvailable = false;\n                    this.socket.disconnect();\n                }\n            });\n            // Handle disconnect\n            this.socket.on('disconnect', (reason) => {\n                console.log(`[Socket.io] Disconnected: ${reason}`);\n            });\n            // Handle errors from server\n            this.socket.on('error', (data) => {\n                console.error('[Socket.io] Error from server:', data);\n                if (data && data.message) {\n                    alert(`Erreur: ${data.message}`);\n                }\n            });\n            // Setup handlers for standard events we're interested in\n            ['friend-request-received', 'friend-request-sent', 'friend-request-accepted',\n                'friend-request-rejected', 'friend-removed', 'friend-status-change',\n                'game-invitation', 'game-started'].forEach(event => {\n                this.socket.on(event, (data) => {\n                    var _a;\n                    console.log(`[Socket.io] Received ${event} event:`, data);\n                    // Add type field if not present\n                    if (!data.type) {\n                        data.type = event;\n                    }\n                    // Forward to our listeners\n                    if (this.listeners.has(event)) {\n                        (_a = this.listeners.get(event)) === null || _a === void 0 ? void 0 : _a.forEach(callback => callback(data));\n                    }\n                });\n            });\n        }\n        catch (error) {\n            console.error('[Socket.io] Initialization error:', error);\n            this.attemptReconnect();\n        }\n    }\n    // Disconnect from the Socket.io server\n    disconnect() {\n        if (this.socket) {\n            console.log('[Socket.io] Disconnecting');\n            this.socket.disconnect();\n            this.socket = null;\n        }\n        this.reconnectAttempts = 0;\n    }\n    // Subscribe to an event\n    on(event, callback) {\n        var _a;\n        console.log(`[Socket.io] Registering event handler for: ${event}`);\n        if (!this.listeners.has(event)) {\n            this.listeners.set(event, new Set());\n        }\n        (_a = this.listeners.get(event)) === null || _a === void 0 ? void 0 : _a.add(callback);\n        // If already connected, register with socket.io server\n        if (this.socket && this.socket.connected) {\n            console.log(`[Socket.io] Already connected, subscribing to ${event}`);\n            this.socket.on(event, (data) => {\n                console.log(`[Socket.io] Direct event ${event}:`, data);\n                // Add type if missing\n                if (!data.type) {\n                    data.type = event;\n                }\n                callback(data);\n            });\n        }\n    }\n    // Unsubscribe from an event\n    off(event, callback) {\n        const listeners = this.listeners.get(event);\n        if (listeners) {\n            listeners.delete(callback);\n            if (listeners.size === 0) {\n                this.listeners.delete(event);\n                // If connected, remove listener from socket.io\n                if (this.socket && this.socket.connected) {\n                    this.socket.off(event);\n                }\n            }\n        }\n    }\n    // Send a message to the server\n    send(type, data) {\n        if (!this.socket || !this.socket.connected) {\n            console.warn('[Socket.io] Cannot send message: not connected');\n            return false;\n        }\n        try {\n            console.log(`[Socket.io] Emitting ${type}:`, data);\n            this.socket.emit(type, data);\n            return true;\n        }\n        catch (error) {\n            console.error('[Socket.io] Error sending message:', error);\n            return false;\n        }\n    }\n    // Check if connected\n    isConnected() {\n        var _a;\n        console.log('[Socket.io] Checking connection status:', ((_a = this.socket) === null || _a === void 0 ? void 0 : _a.connected) || false);\n        return this.socket && this.socket.connected;\n    }\n    // Reattach all event listeners after reconnect\n    reattachListeners() {\n        if (!this.socket || !this.socket.connected)\n            return;\n        console.log('[Socket.io] Reattaching event listeners');\n        this.listeners.forEach((callbacks, event) => {\n            console.log(`[Socket.io] Resubscribing to event: ${event}`);\n            this.socket.on(event, (data) => {\n                console.log(`[Socket.io] Received reattached ${event}:`, data);\n                // Add type if missing\n                if (!data.type) {\n                    data.type = event;\n                }\n                callbacks.forEach(callback => callback(data));\n            });\n        });\n    }\n    // Attempt to reconnect\n    attemptReconnect() {\n        this.reconnectAttempts++;\n        if (this.reconnectAttempts > this.maxReconnectAttempts) {\n            console.log('[Socket.io] Max reconnect attempts reached, giving up');\n            this.isBackendAvailable = false;\n            return;\n        }\n        const delay = Math.min(10000, this.reconnectDelay * Math.pow(1.5, this.reconnectAttempts - 1));\n        console.log(`[Socket.io] Attempting to reconnect in ${delay}ms (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\n        setTimeout(() => {\n            this.connect();\n        }, delay);\n    }\n}\n// Create a singleton instance\nconst websocketService = new WebSocketService();\n// Export the websocket service\n\n// Make it globally available\nwindow.websocketService = websocketService;\n// Auto-connect if user is authenticated\ndocument.addEventListener('DOMContentLoaded', () => {\n    const token = localStorage.getItem('auth_token');\n    if (token) {\n        console.log('[Socket.io] Auto-connecting...');\n        websocketService.connect();\n    }\n});\n\n\n//# sourceURL=webpack://ft-transcendence-frontend/./src/ts/websocket.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/ts/websocket.ts"](0, __webpack_exports__, __webpack_require__);
/******/ 	
/******/ })()
;