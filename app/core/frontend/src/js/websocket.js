/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/ts/websocket.ts":
/*!*****************************!*\
  !*** ./src/ts/websocket.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   websocketService: () => (/* binding */ websocketService)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// WebSocket URL configuration\nconst WS_URL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'\n    ? 'http://localhost:3000'\n    : window.location.origin; // Use the same origin in production\n// Log the WebSocket URL for debugging\nconsole.log('[Socket.io] Using WebSocket URL:', WS_URL);\n// Constantes partagÃ©es avec auth.ts\nconst TOKEN_KEY = 'auth_token';\nclass WebSocketService {\n    constructor() {\n        this.socket = null; // Socket.io socket instead of WebSocket\n        this.listeners = new Map();\n        this.reconnectAttempts = 0;\n        this.maxReconnectAttempts = 3;\n        this.reconnectDelay = 3000;\n        this.isBackendAvailable = true;\n        this.connectionPromise = null;\n        this.isConnecting = false;\n    }\n    // Connect to the Socket.io server\n    connect() {\n        // Return existing connection promise if already connecting\n        if (this.connectionPromise) {\n            return this.connectionPromise;\n        }\n        if (this.socket && this.socket.connected) {\n            console.log('[Socket.io] Already connected');\n            return Promise.resolve(true);\n        }\n        if (!this.isBackendAvailable) {\n            console.log('[Socket.io] Backend previously marked as unavailable, skipping connection attempt');\n            return Promise.resolve(false);\n        }\n        // Create a new connection promise\n        this.connectionPromise = new Promise((resolve, reject) => {\n            this.isConnecting = true;\n            // Get token from auth service or storage\n            let token = null;\n            // Try to get token from auth service first\n            const authService = window.authService;\n            if (authService && authService.getToken && typeof authService.getToken === 'function') {\n                token = authService.getToken();\n                console.log('[Socket.io] Got token from authService:', !!token);\n            }\n            // Fallback to localStorage if token not available from auth service\n            if (!token) {\n                token = localStorage.getItem(TOKEN_KEY);\n                console.log('[Socket.io] Got token from localStorage:', !!token);\n            }\n            if (!token) {\n                console.log('[Socket.io] No token available for connection');\n                this.isConnecting = false;\n                this.connectionPromise = null;\n                resolve(false);\n                return;\n            }\n            try {\n                // Close any existing connection\n                this.disconnect();\n                // Import Socket.io client from CDN if not already available\n                if (typeof io === 'undefined') {\n                    console.log('[Socket.io] io not defined, loading script from CDN');\n                    const script = document.createElement('script');\n                    script.src = 'https://cdn.socket.io/4.6.0/socket.io.min.js';\n                    script.onload = () => this.initializeSocket(token, resolve, reject);\n                    script.onerror = () => {\n                        console.error('[Socket.io] Failed to load Socket.io script');\n                        this.isConnecting = false;\n                        this.connectionPromise = null;\n                        reject(new Error('Failed to load Socket.io script'));\n                    };\n                    document.head.appendChild(script);\n                }\n                else {\n                    this.initializeSocket(token, resolve, reject);\n                }\n            }\n            catch (error) {\n                console.error('[Socket.io] Setup error:', error);\n                this.isConnecting = false;\n                this.connectionPromise = null;\n                reject(error);\n            }\n        });\n        return this.connectionPromise;\n    }\n    // Initialize Socket.io connection\n    initializeSocket(token, resolve, reject) {\n        console.log('[Socket.io] Initializing connection');\n        try {\n            // Log the original token format for debugging\n            console.log('[Socket.io] Original token format:', token.startsWith('Bearer ') ? 'Has Bearer prefix' : 'No Bearer prefix');\n            // Remove Bearer prefix if it exists, to ensure we're not double-prefixing\n            const cleanToken = token.startsWith('Bearer ') ? token.substring(7) : token;\n            const tokenPreview = cleanToken.length > 20\n                ? cleanToken.substring(0, 15) + '...' + cleanToken.substring(cleanToken.length - 5)\n                : cleanToken;\n            console.log('[Socket.io] Token prepared for connection:', tokenPreview);\n            // Connect to Socket.io server with clean token (no Bearer prefix)\n            this.socket = io(WS_URL, {\n                auth: { token: cleanToken },\n                reconnection: true,\n                reconnectionAttempts: this.maxReconnectAttempts,\n                reconnectionDelay: this.reconnectDelay,\n                timeout: 10000\n            });\n            // Connection success\n            this.socket.on('connect', () => {\n                console.log('[Socket.io] Connected successfully');\n                this.reconnectAttempts = 0;\n                this.isBackendAvailable = true;\n                this.isConnecting = false;\n                this.connectionPromise = null;\n                // Wait a bit before reattaching listeners to ensure connection is stable\n                setTimeout(() => {\n                    this.reattachListeners();\n                    resolve(true);\n                }, 100);\n            });\n            // Connection error\n            this.socket.on('connect_error', (error) => {\n                console.error('[Socket.io] Connection error:', error);\n                this.reconnectAttempts++;\n                if (this.reconnectAttempts > this.maxReconnectAttempts) {\n                    console.log('[Socket.io] Max reconnect attempts reached, giving up');\n                    this.isBackendAvailable = false;\n                    this.isConnecting = false;\n                    this.connectionPromise = null;\n                    this.socket.disconnect();\n                    reject(error);\n                }\n            });\n            // Handle disconnect\n            this.socket.on('disconnect', (reason) => {\n                console.log(`[Socket.io] Disconnected: ${reason}`);\n                this.isConnecting = false;\n                this.connectionPromise = null;\n                // Auto-reconnect for certain disconnect reasons\n                if (reason === 'io server disconnect') {\n                    // Server initiated disconnect, try to reconnect\n                    setTimeout(() => {\n                        this.connect();\n                    }, 2000);\n                }\n            });\n            // Handle errors from server\n            this.socket.on('error', (data) => {\n                console.error('[Socket.io] Error from server:', data);\n                if (data && data.message) {\n                    console.error(`WebSocket Error: ${data.message}`);\n                }\n            });\n            // Setup handlers for standard events we're interested in\n            ['friend-request-received', 'friend-request-sent', 'friend-request-accepted',\n                'friend-request-rejected', 'friend-removed', 'friend-status-change',\n                'game-invitation', 'game-started'].forEach(event => {\n                this.socket.on(event, (data) => {\n                    var _a;\n                    console.log(`[Socket.io] Received ${event} event:`, data);\n                    // Add type field if not present\n                    if (!data.type) {\n                        data.type = event;\n                    }\n                    // Forward to our listeners\n                    if (this.listeners.has(event)) {\n                        (_a = this.listeners.get(event)) === null || _a === void 0 ? void 0 : _a.forEach(callback => callback(data));\n                    }\n                });\n            });\n        }\n        catch (error) {\n            console.error('[Socket.io] Initialization error:', error);\n            this.isConnecting = false;\n            this.connectionPromise = null;\n            reject(error);\n        }\n    }\n    // Disconnect from the Socket.io server\n    disconnect() {\n        if (this.socket) {\n            console.log('[Socket.io] Disconnecting');\n            this.socket.disconnect();\n            this.socket = null;\n        }\n        this.reconnectAttempts = 0;\n        this.isConnecting = false;\n        this.connectionPromise = null;\n    }\n    // Subscribe to an event\n    on(event, callback) {\n        var _a;\n        console.log(`[Socket.io] Registering event handler for: ${event}`);\n        if (!this.listeners.has(event)) {\n            this.listeners.set(event, new Set());\n        }\n        (_a = this.listeners.get(event)) === null || _a === void 0 ? void 0 : _a.add(callback);\n        // If already connected, register with socket.io server\n        if (this.socket && this.socket.connected) {\n            console.log(`[Socket.io] Already connected, subscribing to ${event}`);\n            // Remove existing listeners for this event to avoid duplicates\n            this.socket.off(event);\n            this.socket.on(event, (data) => {\n                console.log(`[Socket.io] Direct event ${event}:`, data);\n                // Add type if missing\n                if (!data.type) {\n                    data.type = event;\n                }\n                // Call all callbacks for this event\n                const eventCallbacks = this.listeners.get(event);\n                if (eventCallbacks) {\n                    eventCallbacks.forEach(cb => cb(data));\n                }\n            });\n        }\n    }\n    // Unsubscribe from an event\n    off(event, callback) {\n        const listeners = this.listeners.get(event);\n        if (listeners) {\n            listeners.delete(callback);\n            if (listeners.size === 0) {\n                this.listeners.delete(event);\n                // If connected, remove listener from socket.io\n                if (this.socket && this.socket.connected) {\n                    this.socket.off(event);\n                }\n            }\n        }\n    }\n    // Send a message to the server with connection check\n    send(type, data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Ensure we're connected before sending\n            if (!this.isConnected()) {\n                console.log('[Socket.io] Not connected, attempting to connect before sending message');\n                try {\n                    const connected = yield this.connect();\n                    if (!connected) {\n                        console.warn('[Socket.io] Failed to connect, cannot send message');\n                        return false;\n                    }\n                    // Wait a bit more to ensure connection is stable\n                    yield new Promise(resolve => setTimeout(resolve, 200));\n                }\n                catch (error) {\n                    console.error('[Socket.io] Connection failed:', error);\n                    return false;\n                }\n            }\n            if (!this.socket || !this.socket.connected) {\n                console.warn('[Socket.io] Cannot send message: not connected');\n                return false;\n            }\n            try {\n                console.log(`[Socket.io] Emitting ${type}:`, data);\n                this.socket.emit(type, data);\n                return true;\n            }\n            catch (error) {\n                console.error('[Socket.io] Error sending message:', error);\n                return false;\n            }\n        });\n    }\n    // Check if connected\n    isConnected() {\n        const connected = this.socket && this.socket.connected;\n        console.log('[Socket.io] Checking connection status:', connected || false);\n        return connected;\n    }\n    // Check if currently connecting\n    isCurrentlyConnecting() {\n        return this.isConnecting;\n    }\n    // Reattach all event listeners after reconnect\n    reattachListeners() {\n        if (!this.socket || !this.socket.connected)\n            return;\n        console.log('[Socket.io] Reattaching event listeners');\n        // Don't clear all listeners, just reattach our custom ones\n        this.listeners.forEach((callbacks, event) => {\n            console.log(`[Socket.io] Resubscribing to event: ${event}`);\n            // Remove existing listener for this event to avoid duplicates\n            this.socket.off(event);\n            this.socket.on(event, (data) => {\n                console.log(`[Socket.io] Received reattached ${event}:`, data);\n                // Add type if missing\n                if (!data.type) {\n                    data.type = event;\n                }\n                callbacks.forEach(callback => callback(data));\n            });\n        });\n    }\n    // Attempt to reconnect\n    attemptReconnect() {\n        this.reconnectAttempts++;\n        if (this.reconnectAttempts > this.maxReconnectAttempts) {\n            console.log('[Socket.io] Max reconnect attempts reached, giving up');\n            this.isBackendAvailable = false;\n            return;\n        }\n        const delay = Math.min(10000, this.reconnectDelay * Math.pow(1.5, this.reconnectAttempts - 1));\n        console.log(`[Socket.io] Attempting to reconnect in ${delay}ms (attempt ${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\n        setTimeout(() => {\n            this.connect();\n        }, delay);\n    }\n}\n// Create a singleton instance\nconst websocketService = new WebSocketService();\n// Export the websocket service\n\n// Make it globally available\nwindow.websocketService = websocketService;\n// Auto-connect if user is authenticated\ndocument.addEventListener('DOMContentLoaded', () => __awaiter(void 0, void 0, void 0, function* () {\n    const token = localStorage.getItem('auth_token');\n    if (token) {\n        console.log('[Socket.io] Auto-connecting...');\n        try {\n            yield websocketService.connect();\n            console.log('[Socket.io] Auto-connection successful');\n        }\n        catch (error) {\n            console.error('[Socket.io] Auto-connection failed:', error);\n        }\n    }\n}));\n\n\n//# sourceURL=webpack://ft-transcendence-frontend/./src/ts/websocket.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/ts/websocket.ts"](0, __webpack_exports__, __webpack_require__);
/******/ 	
/******/ })()
;