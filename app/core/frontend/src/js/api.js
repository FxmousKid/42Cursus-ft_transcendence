/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/ts/api.ts":
/*!***********************!*\
  !*** ./src/ts/api.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   api: () => (/* binding */ api)\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n// API URL configuration\nconst API_URL = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'\n    ? 'http://localhost:3000'\n    : window.location.origin; // Use the same origin in production\n// Helper for API requests\nfunction request(endpoint_1) {\n    return __awaiter(this, arguments, void 0, function* (endpoint, options = {}) {\n        try {\n            const url = `${API_URL}${endpoint}`;\n            console.log(`[API] Making ${options.method || 'GET'} request to: ${url}`);\n            // Get the most up-to-date token\n            const authService = window.authService;\n            let token;\n            if (authService && authService.getToken) {\n                // Get the token directly from auth service if available\n                token = authService.getToken();\n                console.log(`[API] Got token from authService: ${!!token}`);\n            }\n            else {\n                // Fallback to localStorage\n                token = localStorage.getItem('auth_token');\n                console.log(`[API] Got token from localStorage: ${!!token}`);\n            }\n            // Prepare headers\n            const headers = Object.assign(Object.assign({ 'Content-Type': 'application/json', 'Accept': 'application/json' }, (token && { 'Authorization': `Bearer ${token}` })), options.headers);\n            // Add a timeout to the fetch request\n            const controller = new AbortController();\n            const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout\n            const response = yield fetch(url, Object.assign(Object.assign({}, options), { headers, mode: 'cors', credentials: 'include', signal: controller.signal }));\n            clearTimeout(timeoutId); // Clear the timeout\n            console.log(`[API] Response status: ${response.status}`);\n            // Handle authentication errors\n            if (response.status === 401) {\n                console.log('[API] Authentication error (401) received');\n                // Use the auth service to clear the session if available\n                if (authService && authService.clearSession) {\n                    console.log('[API] Using authService to clear session');\n                    authService.clearSession();\n                }\n                else {\n                    // Fallback manual cleanup\n                    console.log('[API] Manually clearing auth data from storage');\n                    localStorage.removeItem('auth_token');\n                    localStorage.removeItem('user_id');\n                    localStorage.removeItem('username');\n                    localStorage.removeItem('avatar_url');\n                    sessionStorage.removeItem('auth_token');\n                    sessionStorage.removeItem('user_id');\n                    sessionStorage.removeItem('username');\n                    sessionStorage.removeItem('avatar_url');\n                }\n                // Get the current path and check if we need to redirect\n                const currentPath = window.location.pathname;\n                // Don't redirect if already on login page to avoid redirect loop\n                if (!currentPath.includes('login') && !currentPath.includes('register')) {\n                    console.log('[API] Redirecting to login page due to 401 error');\n                    window.location.href = '/login.html';\n                }\n                else {\n                    console.log('[API] Already on login/register page, not redirecting');\n                }\n                return {\n                    success: false,\n                    message: 'Authentication required'\n                };\n            }\n            // Handle 404 errors\n            if (response.status === 404) {\n                console.warn(`[API] Endpoint not found: ${endpoint}`);\n                return {\n                    success: false,\n                    message: `Endpoint not found: ${endpoint}`,\n                    data: [] // Renvoyer un tableau vide par défaut\n                };\n            }\n            // Handle no content response\n            if (response.status === 204) {\n                return { success: true };\n            }\n            let data;\n            try {\n                const text = yield response.text();\n                data = text ? JSON.parse(text) : {};\n            }\n            catch (error) {\n                console.error('Error parsing response:', error);\n                return {\n                    success: false,\n                    message: 'Failed to parse server response'\n                };\n            }\n            if (!response.ok) {\n                return {\n                    success: false,\n                    message: data.message || 'An error occurred'\n                };\n            }\n            return data;\n        }\n        catch (error) {\n            console.error('API request failed:', error);\n            if (error instanceof TypeError && error.message === 'Failed to fetch') {\n                console.warn('[API] Failed to fetch. The backend server may be down or unreachable.');\n                // Show a user-friendly message in the console that could be displayed to the user\n                console.log('[API] Connection to server failed. Please check if the backend is running.');\n            }\n            return {\n                success: false,\n                message: error instanceof Error ? error.message : 'Unknown error',\n                data: [] // Return an empty array by default\n            };\n        }\n    });\n}\n// Create and export API object\nconst api = {\n    baseUrl: API_URL,\n    // Auth services\n    auth: {\n        login(email, password) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/auth/login', {\n                    method: 'POST',\n                    body: JSON.stringify({ email, password })\n                });\n            });\n        },\n        register(username, email, password) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/auth/register', {\n                    method: 'POST',\n                    body: JSON.stringify({ username, email, password })\n                });\n            });\n        },\n        logout() {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/auth/logout', {\n                    method: 'POST'\n                });\n            });\n        }\n    },\n    // User services\n    user: {\n        getProfile() {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/users/profile'); // Use /users/profile instead of /users/${id}\n            });\n        },\n        updateProfile(data) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/users/profile', {\n                    method: 'PUT', // Use PUT instead of PATCH to match backend\n                    body: JSON.stringify(data)\n                });\n            });\n        },\n        getMatches() {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/users/matches');\n            });\n        },\n        getAll() {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/users');\n            });\n        },\n        searchUsers(username) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request(`/users/search?username=${encodeURIComponent(username)}`);\n            });\n        }\n    },\n    // Friendship services\n    friendship: {\n        getFriends() {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/friendships');\n            });\n        },\n        getPendingRequests() {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/friendships/requests');\n            });\n        },\n        sendFriendRequest(friendId) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/friendships/request', {\n                    method: 'POST',\n                    body: JSON.stringify({ friend_id: friendId })\n                });\n            });\n        },\n        acceptFriendRequest(requestId) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request(`/friendships/accept/${requestId}`, {\n                    method: 'POST'\n                });\n            });\n        },\n        rejectFriendRequest(requestId) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request(`/friendships/reject/${requestId}`, {\n                    method: 'POST'\n                });\n            });\n        },\n        removeFriend(friendId) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request(`/friendships/${friendId}`, {\n                    method: 'DELETE'\n                });\n            });\n        }\n    },\n    // Game services\n    game: {\n        getAllMatches() {\n            return __awaiter(this, void 0, void 0, function* () {\n                return request('/matches');\n            });\n        }\n    }\n};\n// Pour la rétrocompatibilité, on expose aussi API globalement\nif (typeof window !== 'undefined') {\n    window.api = api;\n}\n\n\n//# sourceURL=webpack://ft-transcendence-frontend/./src/ts/api.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/ts/api.ts"](0, __webpack_exports__, __webpack_require__);
/******/ 	
/******/ })()
;