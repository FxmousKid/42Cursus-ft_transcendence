/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/ts/game.ts":
/*!************************!*\
  !*** ./src/ts/game.ts ***!
  \************************/
/***/ (() => {

eval("\n// ts/game.ts - Pong Game Implementation with TypeScript\n// Initialize the game when DOM is loaded\ndocument.addEventListener('DOMContentLoaded', function () {\n    // Game canvas and context\n    const canvas = document.getElementById('game-canvas');\n    const ctx = canvas.getContext('2d');\n    // Game constants\n    const WINNING_SCORE = 10;\n    const PADDLE_ENLARGE_FACTOR = 1.5; // How much larger the paddle gets\n    const PADDLE_ENLARGE_DURATION = 5000; // Duration of enlargement in milliseconds\n    const CENTER_MARKER_SIZE = 8; // Size of the red center marker\n    const PERFECT_HIT_TOLERANCE = 10; // How close to center counts as a \"perfect\" hit\n    const ball = {\n        x: canvas.width / 2,\n        y: canvas.height / 2,\n        radius: 10,\n        velocityX: 0, // Will be set in resetBall()\n        velocityY: 0, // Will be set in resetBall()\n        speed: 2, // Current speed (starts slow)\n        baseSpeed: 2, // Base speed for resets\n        color: 'white'\n    };\n    const paddleWidth = 10;\n    const paddleHeight = 100;\n    const paddleOffset = 20;\n    const leftPaddle = {\n        x: paddleOffset,\n        y: (canvas.height - paddleHeight) / 2,\n        width: paddleWidth,\n        height: paddleHeight,\n        score: 0,\n        color: 'white',\n        moveUp: false,\n        moveDown: false,\n        speed: 8,\n        originalHeight: paddleHeight,\n        enlargeTimer: null\n    };\n    const rightPaddle = {\n        x: canvas.width - paddleOffset - paddleWidth,\n        y: (canvas.height - paddleHeight) / 2,\n        width: paddleWidth,\n        height: paddleHeight,\n        score: 0,\n        color: 'white',\n        moveUp: false,\n        moveDown: false,\n        speed: 8,\n        originalHeight: paddleHeight,\n        enlargeTimer: null\n    };\n    // Game state\n    let gameRunning = false;\n    let gamePaused = false;\n    let gameOver = false;\n    let winner = '';\n    // DOM elements\n    const startButton = document.getElementById('start-button');\n    const resetButton = document.getElementById('reset-button');\n    const leftScoreDisplay = document.getElementById('player-left-score');\n    const rightScoreDisplay = document.getElementById('player-right-score');\n    // Event listeners for paddles\n    document.addEventListener('keydown', function (event) {\n        if (gameOver)\n            return; // Don't allow controls if game is over\n        // Left paddle (Q - up, W - down)\n        if (event.code === 'KeyQ') {\n            leftPaddle.moveUp = true;\n        }\n        else if (event.code === 'KeyW') {\n            leftPaddle.moveDown = true;\n        }\n        // Right paddle (Left arrow - up, Right arrow - down)\n        if (event.code === 'ArrowLeft') {\n            rightPaddle.moveUp = true;\n        }\n        else if (event.code === 'ArrowRight') {\n            rightPaddle.moveDown = true;\n        }\n        // Add pause toggle on 'P' key press\n        if (event.code === 'KeyP' && gameRunning) {\n            gamePaused = !gamePaused;\n            if (gamePaused) {\n                startButton.textContent = \"Reprendre\";\n                startButton.classList.remove('bg-yellow-500', 'hover:bg-yellow-600');\n                startButton.classList.add('bg-green-500', 'hover:bg-green-600');\n            }\n            else {\n                startButton.textContent = \"Pause\";\n                startButton.classList.remove('bg-green-500', 'hover:bg-green-600');\n                startButton.classList.add('bg-yellow-500', 'hover:bg-yellow-600');\n            }\n        }\n    });\n    document.addEventListener('keyup', function (event) {\n        // Left paddle\n        if (event.code === 'KeyQ') {\n            leftPaddle.moveUp = false;\n        }\n        else if (event.code === 'KeyW') {\n            leftPaddle.moveDown = false;\n        }\n        // Right paddle\n        if (event.code === 'ArrowLeft') {\n            rightPaddle.moveUp = false;\n        }\n        else if (event.code === 'ArrowRight') {\n            rightPaddle.moveDown = false;\n        }\n    });\n    // Button controls\n    startButton.addEventListener('click', function () {\n        if (gameOver) {\n            // If game is over, reset everything and start a new game\n            gameOver = false;\n            winner = '';\n            resetGame();\n            startGame();\n        }\n        else if (!gameRunning) {\n            // Start the game if it's not running\n            gameRunning = true;\n            gamePaused = false;\n            startButton.textContent = \"Pause\";\n            startButton.classList.remove('bg-blue-500', 'hover:bg-blue-600');\n            startButton.classList.add('bg-yellow-500', 'hover:bg-yellow-600');\n            startGame();\n        }\n        else {\n            // Toggle pause if the game is already running\n            gamePaused = !gamePaused;\n            if (gamePaused) {\n                // Game is now paused\n                startButton.textContent = \"Reprendre\";\n                startButton.classList.remove('bg-yellow-500', 'hover:bg-yellow-600');\n                startButton.classList.add('bg-green-500', 'hover:bg-green-600');\n            }\n            else {\n                // Game is now resumed\n                startButton.textContent = \"Pause\";\n                startButton.classList.remove('bg-green-500', 'hover:bg-green-600');\n                startButton.classList.add('bg-yellow-500', 'hover:bg-yellow-600');\n            }\n        }\n    });\n    resetButton.addEventListener('click', function () {\n        // Reset the game\n        resetGame();\n        // Reset game state\n        gameOver = false;\n        winner = '';\n        // Reset the pause state and button appearance if game is running\n        if (gameRunning) {\n            gamePaused = false;\n            startButton.textContent = \"Pause\";\n            startButton.classList.remove('bg-green-500', 'hover:bg-green-600');\n            startButton.classList.add('bg-yellow-500', 'hover:bg-yellow-600');\n        }\n    });\n    // Function to enlarge a paddle when there's a perfect hit\n    // Constants for progressive paddle growth\n    const PADDLE_ENLARGE_INCREMENT = 0.2; // Each perfect hit adds 20% to the original size\n    const MAX_PADDLE_SIZE_FACTOR = 2.5; // Maximum size is 250% of original\n    function enlargePaddle(paddle) {\n        // Clear any existing timer (if we're using timers elsewhere)\n        if (paddle.enlargeTimer !== null) {\n            clearTimeout(paddle.enlargeTimer);\n            paddle.enlargeTimer = null;\n        }\n        // Calculate center position before enlarging\n        const paddleCenter = paddle.y + paddle.height / 2;\n        // Determine current size relative to original\n        const currentSizeFactor = paddle.height / paddle.originalHeight;\n        // Incrementally enlarge the paddle, up to the maximum size\n        const newSizeFactor = Math.min(currentSizeFactor + PADDLE_ENLARGE_INCREMENT, MAX_PADDLE_SIZE_FACTOR);\n        // Apply the new size\n        paddle.height = paddle.originalHeight * newSizeFactor;\n        // Re-center the paddle at the same center point\n        paddle.y = paddleCenter - paddle.height / 2;\n        // Keep paddle within canvas boundaries\n        if (paddle.y < 0) {\n            paddle.y = 0;\n        }\n        else if (paddle.y + paddle.height > canvas.height) {\n            paddle.y = canvas.height - paddle.height;\n        }\n        // Visual feedback for the enlargement (optional)\n        console.log(`Paddle enlarged! New size factor: ${newSizeFactor.toFixed(2)}`);\n    }\n    // Drawing functions\n    function drawRect(x, y, width, height, color) {\n        ctx.fillStyle = color;\n        ctx.fillRect(x, y, width, height);\n    }\n    function drawCircle(x, y, radius, color) {\n        // Calculate color based on speed - ball gets more red as it speeds up\n        const speedRatio = Math.min((ball.speed - ball.baseSpeed) / 10, 1);\n        const r = Math.floor(255);\n        const g = Math.floor(255 * (1 - speedRatio * 0.7));\n        const b = Math.floor(255 * (1 - speedRatio * 0.7));\n        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;\n        ctx.beginPath();\n        ctx.arc(x, y, radius, 0, Math.PI * 2, false);\n        ctx.closePath();\n        ctx.fill();\n    }\n    function drawNet() {\n        const netWidth = 2;\n        const netHeight = 10;\n        const netGap = 15;\n        for (let y = 0; y <= canvas.height; y += netHeight + netGap) {\n            drawRect(canvas.width / 2 - netWidth / 2, y, netWidth, netHeight, 'rgba(255, 255, 255, 0.5)');\n        }\n    }\n    function drawPaddle(paddle) {\n        // Draw the main paddle\n        drawRect(paddle.x, paddle.y, paddle.width, paddle.height, paddle.color);\n        // Draw the red center marker\n        const centerY = paddle.y + (paddle.height / 2) - (CENTER_MARKER_SIZE / 2);\n        drawRect(paddle.x, centerY, paddle.width, CENTER_MARKER_SIZE, '#FF4136');\n    }\n    function drawScore() {\n        leftScoreDisplay.textContent = leftPaddle.score.toString();\n        rightScoreDisplay.textContent = rightPaddle.score.toString();\n    }\n    // Collision detection\n    function collision(ball, paddle) {\n        // Check if ball coordinates are within paddle boundaries\n        return (ball.x + ball.radius > paddle.x &&\n            ball.x - ball.radius < paddle.x + paddle.width &&\n            ball.y + ball.radius > paddle.y &&\n            ball.y - ball.radius < paddle.y + paddle.height);\n    }\n    // Check if it's a perfect center hit\n    function isPerfectHit(ball, paddle) {\n        const paddleCenter = paddle.y + paddle.height / 2;\n        return Math.abs(ball.y - paddleCenter) < PERFECT_HIT_TOLERANCE;\n    }\n    // Game logic\n    function update() {\n        // Don't update the game if it's not running, paused, or over\n        if (!gameRunning || gamePaused || gameOver)\n            return;\n        // Move left paddle\n        if (leftPaddle.moveUp && leftPaddle.y > 0) {\n            leftPaddle.y -= leftPaddle.speed;\n        }\n        else if (leftPaddle.moveDown && leftPaddle.y + leftPaddle.height < canvas.height) {\n            leftPaddle.y += leftPaddle.speed;\n        }\n        // Move right paddle\n        if (rightPaddle.moveUp && rightPaddle.y > 0) {\n            rightPaddle.y -= rightPaddle.speed;\n        }\n        else if (rightPaddle.moveDown && rightPaddle.y + rightPaddle.height < canvas.height) {\n            rightPaddle.y += rightPaddle.speed;\n        }\n        // Update ball position\n        ball.x += ball.velocityX;\n        ball.y += ball.velocityY;\n        // Wall collision (top and bottom)\n        if (ball.y + ball.radius > canvas.height || ball.y - ball.radius < 0) {\n            ball.velocityY = -ball.velocityY;\n        }\n        // Determine which paddle is being hit by the ball\n        let player = (ball.x < canvas.width / 2) ? leftPaddle : rightPaddle;\n        // If the ball hits a paddle\n        if (collision(ball, player)) {\n            // Check if it's a perfect center hit\n            if (isPerfectHit(ball, player)) {\n                // Perfect hit! Enlarge the paddle\n                enlargePaddle(player);\n                // Add some visual/audio feedback for the perfect hit\n                // (you could add sound effects here)\n            }\n            // Where the ball hit the paddle\n            let collidePoint = ball.y - (player.y + player.height / 2);\n            // Normalize the value of collidePoint\n            collidePoint = collidePoint / (player.height / 2);\n            // Calculate angle in radians\n            let angleRad = collidePoint * (Math.PI / 4);\n            // X direction of the ball\n            let direction = (ball.x < canvas.width / 2) ? 1 : -1;\n            // Increase speed on each hit\n            ball.speed += 0.5;\n            // Change velocity based on new speed\n            ball.velocityX = direction * ball.speed * Math.cos(angleRad);\n            ball.velocityY = ball.speed * Math.sin(angleRad);\n        }\n        // Scoring - ball goes beyond paddles\n        if (ball.x - ball.radius < 0) {\n            // Right player scores\n            rightPaddle.score++;\n            // Check for win\n            if (rightPaddle.score >= WINNING_SCORE) {\n                gameOver = true;\n                winner = 'Joueur 2';\n                startButton.textContent = \"Nouvelle Partie\";\n                startButton.classList.remove('bg-yellow-500', 'hover:bg-yellow-600');\n                startButton.classList.add('bg-blue-500', 'hover:bg-blue-600');\n            }\n            else {\n                resetBall();\n            }\n        }\n        else if (ball.x + ball.radius > canvas.width) {\n            // Left player scores\n            leftPaddle.score++;\n            // Check for win\n            if (leftPaddle.score >= WINNING_SCORE) {\n                gameOver = true;\n                winner = 'Joueur 1';\n                startButton.textContent = \"Nouvelle Partie\";\n                startButton.classList.remove('bg-yellow-500', 'hover:bg-yellow-600');\n                startButton.classList.add('bg-blue-500', 'hover:bg-blue-600');\n            }\n            else {\n                resetBall();\n            }\n        }\n        // Update score display\n        drawScore();\n    }\n    function resetBall() {\n        ball.x = canvas.width / 2;\n        ball.y = canvas.height / 2;\n        // Reset speed to base (slow) speed\n        ball.speed = ball.baseSpeed;\n        // Reset paddle sizes when a point is scored\n        // Clear any enlarge timers first\n        if (leftPaddle.enlargeTimer !== null) {\n            clearTimeout(leftPaddle.enlargeTimer);\n            leftPaddle.enlargeTimer = null;\n        }\n        if (rightPaddle.enlargeTimer !== null) {\n            clearTimeout(rightPaddle.enlargeTimer);\n            rightPaddle.enlargeTimer = null;\n        }\n        // Reset paddles to original height\n        leftPaddle.height = leftPaddle.originalHeight;\n        rightPaddle.height = rightPaddle.originalHeight;\n        // Recenter paddles\n        leftPaddle.y = (canvas.height - leftPaddle.height) / 2;\n        rightPaddle.y = (canvas.height - rightPaddle.height) / 2;\n        // Set a random angle, but avoid too vertical trajectories\n        let angle = (Math.random() * 0.5 + 0.25) * Math.PI; // angle between PI/4 and 3PI/4\n        // 50% chance of going left or right\n        if (Math.random() < 0.5) {\n            angle = Math.PI - angle; // Reflect angle to go left\n        }\n        // Calculate velocity components based on reset speed and angle\n        ball.velocityX = ball.speed * Math.cos(angle);\n        ball.velocityY = ball.speed * Math.sin(angle) * (Math.random() < 0.5 ? 1 : -1); // Random up/down\n    }\n    function resetGame() {\n        // Reset scores\n        leftPaddle.score = 0;\n        rightPaddle.score = 0;\n        // Reset paddles position and size\n        leftPaddle.height = leftPaddle.originalHeight;\n        rightPaddle.height = rightPaddle.originalHeight;\n        leftPaddle.y = (canvas.height - leftPaddle.height) / 2;\n        rightPaddle.y = (canvas.height - rightPaddle.height) / 2;\n        // Clear any enlarge timers\n        if (leftPaddle.enlargeTimer !== null) {\n            clearTimeout(leftPaddle.enlargeTimer);\n            leftPaddle.enlargeTimer = null;\n        }\n        if (rightPaddle.enlargeTimer !== null) {\n            clearTimeout(rightPaddle.enlargeTimer);\n            rightPaddle.enlargeTimer = null;\n        }\n        // Reset ball and its velocity\n        resetBall();\n        // Update score display\n        drawScore();\n        // Redraw the game\n        render();\n    }\n    function render() {\n        // Clear the canvas\n        drawRect(0, 0, canvas.width, canvas.height, '#111827');\n        // Draw the net\n        drawNet();\n        // Draw paddles with center markers\n        drawPaddle(leftPaddle);\n        drawPaddle(rightPaddle);\n        // Draw the ball\n        drawCircle(ball.x, ball.y, ball.radius, ball.color);\n        // Optional: Display current ball speed for debugging\n        ctx.fillStyle = 'white';\n        ctx.font = '12px Arial';\n        ctx.fillText(`Ball Speed: ${ball.speed.toFixed(1)}`, 10, 20);\n        // Display game information\n        if (gameOver) {\n            // Game over overlay\n            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            ctx.fillStyle = 'white';\n            ctx.font = 'bold 48px Arial';\n            ctx.textAlign = 'center';\n            ctx.fillText('PARTIE TERMINÃ‰E', canvas.width / 2, canvas.height / 2 - 50);\n            ctx.font = 'bold 32px Arial';\n            ctx.fillText(`${winner} gagne!`, canvas.width / 2, canvas.height / 2 + 10);\n            ctx.font = '20px Arial';\n            ctx.fillText('Cliquez sur \"Nouvelle Partie\" pour recommencer', canvas.width / 2, canvas.height / 2 + 60);\n            ctx.textAlign = 'left'; // Reset text alignment\n        }\n        else if (gamePaused && gameRunning) {\n            // Pause overlay\n            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            ctx.fillStyle = 'white';\n            ctx.font = 'bold 32px Arial';\n            ctx.textAlign = 'center';\n            ctx.fillText('PAUSE', canvas.width / 2, canvas.height / 2);\n            ctx.textAlign = 'left'; // Reset text alignment\n        }\n    }\n    function gameLoop() {\n        update();\n        render();\n        requestAnimationFrame(gameLoop);\n    }\n    function startGame() {\n        resetGame();\n        gameRunning = true;\n        gamePaused = false;\n        gameOver = false;\n        winner = '';\n        startButton.textContent = \"Pause\";\n        startButton.classList.remove('bg-blue-500', 'hover:bg-blue-600');\n        startButton.classList.add('bg-yellow-500', 'hover:bg-yellow-600');\n        gameLoop();\n    }\n    // Initialize the game\n    resetGame();\n});\n\n\n//# sourceURL=webpack://ft-transcendence-frontend/./src/ts/game.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/ts/game.ts"]();
/******/ 	
/******/ })()
;