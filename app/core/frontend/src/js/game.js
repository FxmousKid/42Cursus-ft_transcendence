/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/ts/game.ts":
/*!************************!*\
  !*** ./src/ts/game.ts ***!
  \************************/
/***/ (() => {

eval("\n// Improved Pong Game - Cleaner, Simpler, More Efficient\n// Key improvements: Better separation of concerns, simpler physics, more efficient rendering\nclass PongGame {\n    constructor(canvasId) {\n        this.animationId = 0;\n        // Game dimensions\n        this.ASPECT_RATIO = 16 / 10;\n        this.MIN_WIDTH = 320;\n        // Game settings\n        this.WINNING_SCORE = 2;\n        this.BALL_SPEED = 0.5; // Percentage of canvas width per second\n        this.PADDLE_SPEED = 0.6; // Percentage of canvas height per second\n        this.PADDLE_HEIGHT = 0.2; // 20% of canvas height\n        this.PADDLE_WIDTH = 0.02; // 2% of canvas width\n        this.BALL_SIZE = 0.02; // 2% of canvas width\n        // Game state\n        this.gameState = 'menu';\n        this.winner = '';\n        this.lastTime = 0;\n        this.deltaTime = 0;\n        // Game objects (normalized coordinates 0-1)\n        this.ball = {\n            x: 0.5,\n            y: 0.5,\n            vx: 0,\n            vy: 0,\n            speed: this.BALL_SPEED\n        };\n        this.paddles = {\n            left: {\n                y: 0.5,\n                score: 0,\n                up: false,\n                down: false\n            },\n            right: {\n                y: 0.5,\n                score: 0,\n                up: false,\n                down: false\n            }\n        };\n        this.gameLoop = (timestamp = 0) => {\n            this.deltaTime = Math.min((timestamp - this.lastTime) / 1000, 0.1); // Cap at 100ms\n            this.lastTime = timestamp;\n            this.update();\n            this.render();\n            this.animationId = requestAnimationFrame(this.gameLoop);\n        };\n        this.canvas = document.getElementById(canvasId);\n        this.ctx = this.canvas.getContext('2d');\n        // Cache DOM elements\n        this.elements = {\n            startBtn: document.getElementById('start-button'),\n            resetBtn: document.getElementById('reset-button'),\n            leftScore: document.getElementById('player-left-score'),\n            rightScore: document.getElementById('player-right-score'),\n            leftCard: document.getElementById('player-left-card'),\n            rightCard: document.getElementById('player-right-card')\n        };\n        this.init();\n    }\n    init() {\n        this.setupCanvas();\n        this.setupEventListeners();\n        this.resetGame();\n        this.gameLoop();\n    }\n    setupCanvas() {\n        const resize = () => {\n            const container = this.canvas.parentElement;\n            const maxWidth = container.clientWidth - 32;\n            const width = Math.max(this.MIN_WIDTH, Math.min(800, maxWidth));\n            const height = width / this.ASPECT_RATIO;\n            this.canvas.width = width;\n            this.canvas.height = height;\n        };\n        resize();\n        window.addEventListener('resize', resize);\n    }\n    setupEventListeners() {\n        // Keyboard controls\n        const keyMap = {\n            'KeyQ': () => this.paddles.left.up = true,\n            'KeyW': () => this.paddles.left.down = true,\n            'ArrowLeft': () => this.paddles.right.up = true,\n            'ArrowRight': () => this.paddles.right.down = true,\n            'KeyP': () => this.togglePause()\n        };\n        document.addEventListener('keydown', (e) => {\n            if (keyMap[e.code]) {\n                e.preventDefault();\n                keyMap[e.code]();\n            }\n        });\n        document.addEventListener('keyup', (e) => {\n            switch (e.code) {\n                case 'KeyQ':\n                    this.paddles.left.up = false;\n                    break;\n                case 'KeyW':\n                    this.paddles.left.down = false;\n                    break;\n                case 'ArrowLeft':\n                    this.paddles.right.up = false;\n                    break;\n                case 'ArrowRight':\n                    this.paddles.right.down = false;\n                    break;\n            }\n        });\n        // Button controls\n        this.elements.startBtn.addEventListener('click', () => this.handleStartButton());\n        this.elements.resetBtn.addEventListener('click', () => this.resetGame());\n    }\n    handleStartButton() {\n        switch (this.gameState) {\n            case 'menu':\n            case 'gameover':\n                this.startGame();\n                break;\n            case 'playing':\n                this.pauseGame();\n                break;\n            case 'paused':\n                this.resumeGame();\n                break;\n        }\n    }\n    startGame() {\n        this.resetGame();\n        this.gameState = 'playing';\n        this.elements.startBtn.textContent = 'Pause';\n        this.serveBall();\n    }\n    pauseGame() {\n        this.gameState = 'paused';\n        this.elements.startBtn.textContent = 'Reprendre';\n    }\n    resumeGame() {\n        this.gameState = 'playing';\n        this.elements.startBtn.textContent = 'Pause';\n    }\n    togglePause() {\n        if (this.gameState === 'playing') {\n            this.pauseGame();\n        }\n        else if (this.gameState === 'paused') {\n            this.resumeGame();\n        }\n    }\n    resetGame() {\n        this.paddles.left.score = 0;\n        this.paddles.right.score = 0;\n        this.paddles.left.y = 0.5;\n        this.paddles.right.y = 0.5;\n        this.ball.x = 0.5;\n        this.ball.y = 0.5;\n        this.ball.vx = 0;\n        this.ball.vy = 0;\n        this.updateScore();\n        if (this.gameState === 'gameover') {\n            this.gameState = 'menu';\n            this.elements.startBtn.textContent = 'Commencer';\n        }\n    }\n    serveBall() {\n        this.ball.x = 0.5;\n        this.ball.y = 0.5;\n        // Random angle between -45 and 45 degrees\n        const angle = (Math.random() - 0.5) * Math.PI / 2;\n        const direction = Math.random() < 0.5 ? -1 : 1;\n        this.ball.vx = Math.cos(angle) * this.ball.speed * direction;\n        this.ball.vy = Math.sin(angle) * this.ball.speed;\n    }\n    update() {\n        if (this.gameState !== 'playing')\n            return;\n        const dt = this.deltaTime;\n        // Update paddles\n        const paddleSpeed = this.PADDLE_SPEED * dt;\n        if (this.paddles.left.up && this.paddles.left.y > this.PADDLE_HEIGHT / 2) {\n            this.paddles.left.y -= paddleSpeed;\n        }\n        if (this.paddles.left.down && this.paddles.left.y < 1 - this.PADDLE_HEIGHT / 2) {\n            this.paddles.left.y += paddleSpeed;\n        }\n        if (this.paddles.right.up && this.paddles.right.y > this.PADDLE_HEIGHT / 2) {\n            this.paddles.right.y -= paddleSpeed;\n        }\n        if (this.paddles.right.down && this.paddles.right.y < 1 - this.PADDLE_HEIGHT / 2) {\n            this.paddles.right.y += paddleSpeed;\n        }\n        // Update ball\n        this.ball.x += this.ball.vx * dt;\n        this.ball.y += this.ball.vy * dt;\n        // Ball collision with top/bottom\n        if (this.ball.y <= this.BALL_SIZE || this.ball.y >= 1 - this.BALL_SIZE) {\n            this.ball.vy *= -1;\n            this.ball.y = Math.max(this.BALL_SIZE, Math.min(1 - this.BALL_SIZE, this.ball.y));\n        }\n        // Paddle collision\n        const paddleLeft = 0.02;\n        const paddleRight = 0.98;\n        // Left paddle collision\n        if (this.ball.x - this.BALL_SIZE <= paddleLeft + this.PADDLE_WIDTH &&\n            this.ball.x - this.BALL_SIZE > paddleLeft &&\n            this.ball.vx < 0) {\n            const paddleTop = this.paddles.left.y - this.PADDLE_HEIGHT / 2;\n            const paddleBottom = this.paddles.left.y + this.PADDLE_HEIGHT / 2;\n            if (this.ball.y >= paddleTop && this.ball.y <= paddleBottom) {\n                this.ball.vx *= -1;\n                // Add spin based on hit position\n                const relativeY = (this.ball.y - this.paddles.left.y) / (this.PADDLE_HEIGHT / 2);\n                this.ball.vy = relativeY * this.ball.speed * 0.5;\n                // Normalize velocity\n                const speed = Math.sqrt(Math.pow(this.ball.vx, 2) + Math.pow(this.ball.vy, 2));\n                this.ball.vx = (this.ball.vx / speed) * this.ball.speed;\n                this.ball.vy = (this.ball.vy / speed) * this.ball.speed;\n                this.ball.x = paddleLeft + this.PADDLE_WIDTH + this.BALL_SIZE;\n            }\n        }\n        // Right paddle collision\n        if (this.ball.x + this.BALL_SIZE >= paddleRight - this.PADDLE_WIDTH &&\n            this.ball.x + this.BALL_SIZE < paddleRight &&\n            this.ball.vx > 0) {\n            const paddleTop = this.paddles.right.y - this.PADDLE_HEIGHT / 2;\n            const paddleBottom = this.paddles.right.y + this.PADDLE_HEIGHT / 2;\n            if (this.ball.y >= paddleTop && this.ball.y <= paddleBottom) {\n                this.ball.vx *= -1;\n                // Add spin\n                const relativeY = (this.ball.y - this.paddles.right.y) / (this.PADDLE_HEIGHT / 2);\n                this.ball.vy = relativeY * this.ball.speed * 0.5;\n                // Normalize velocity\n                const speed = Math.sqrt(Math.pow(this.ball.vx, 2) + Math.pow(this.ball.vy, 2));\n                this.ball.vx = (this.ball.vx / speed) * this.ball.speed;\n                this.ball.vy = (this.ball.vy / speed) * this.ball.speed;\n                this.ball.x = paddleRight - this.PADDLE_WIDTH - this.BALL_SIZE;\n            }\n        }\n        // Scoring\n        if (this.ball.x < 0) {\n            this.scorePoint('right');\n        }\n        else if (this.ball.x > 1) {\n            this.scorePoint('left');\n        }\n    }\n    render() {\n        const { width, height } = this.canvas;\n        const ctx = this.ctx;\n        // Clear canvas\n        ctx.fillStyle = '#111827';\n        ctx.fillRect(0, 0, width, height);\n        // Draw middle line\n        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';\n        ctx.setLineDash([5, 15]);\n        ctx.beginPath();\n        ctx.moveTo(width / 2, 0);\n        ctx.lineTo(width / 2, height);\n        ctx.stroke();\n        ctx.setLineDash([]);\n        // Draw paddles\n        ctx.fillStyle = 'white';\n        const pw = this.PADDLE_WIDTH * width;\n        const ph = this.PADDLE_HEIGHT * height;\n        // Left paddle\n        ctx.fillRect(0.02 * width, (this.paddles.left.y - this.PADDLE_HEIGHT / 2) * height, pw, ph);\n        // Right paddle\n        ctx.fillRect(0.98 * width - pw, (this.paddles.right.y - this.PADDLE_HEIGHT / 2) * height, pw, ph);\n        // Draw ball\n        const ballRadius = this.BALL_SIZE * width / 2;\n        ctx.beginPath();\n        ctx.arc(this.ball.x * width, this.ball.y * height, ballRadius, 0, Math.PI * 2);\n        ctx.fill();\n        // Draw game state overlays\n        if (this.gameState === 'paused') {\n            this.drawOverlay('PAUSE');\n        }\n        else if (this.gameState === 'gameover') {\n            this.drawOverlay(`PARTIE TERMINÉE\\n${this.winner} gagne!`);\n        }\n    }\n    scorePoint(side) {\n        if (this.gameState !== 'playing')\n            return; // Prevent multiple scoring\n        this.gameState = 'scoring'; // Temporarily block further scoring\n        if (side === 'right') {\n            this.paddles.right.score++;\n            this.updateScore();\n            this.highlightWinner(this.elements.rightCard);\n            if (this.paddles.right.score >= this.WINNING_SCORE) {\n                this.endGame('Joueur 2');\n            }\n            else {\n                this.ball.x = 0.5;\n                this.ball.y = 0.5;\n                this.ball.vx = 0;\n                this.ball.vy = 0;\n                setTimeout(() => {\n                    if (this.gameState === 'scoring') {\n                        this.gameState = 'playing';\n                        this.serveBall();\n                    }\n                }, 1000);\n            }\n        }\n        else {\n            this.paddles.left.score++;\n            this.updateScore();\n            this.highlightWinner(this.elements.leftCard);\n            if (this.paddles.left.score >= this.WINNING_SCORE) {\n                this.endGame('Joueur 1');\n            }\n            else {\n                this.ball.x = 0.5;\n                this.ball.y = 0.5;\n                this.ball.vx = 0;\n                this.ball.vy = 0;\n                setTimeout(() => {\n                    if (this.gameState === 'scoring') {\n                        this.gameState = 'playing';\n                        this.serveBall();\n                    }\n                }, 1000);\n            }\n        }\n    }\n    drawOverlay(text) {\n        const { width, height } = this.canvas;\n        const ctx = this.ctx;\n        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n        ctx.fillRect(0, 0, width, height);\n        ctx.fillStyle = 'white';\n        ctx.font = `bold ${width * 0.06}px Arial`;\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        const lines = text.split('\\n');\n        lines.forEach((line, i) => {\n            ctx.fillText(line, width / 2, height / 2 + (i - 0.5) * width * 0.08);\n        });\n    }\n    updateScore() {\n        this.elements.leftScore.textContent = this.paddles.left.score.toString();\n        this.elements.rightScore.textContent = this.paddles.right.score.toString();\n    }\n    highlightWinner(card) {\n        card.classList.add('scoring');\n        setTimeout(() => card.classList.remove('scoring'), 500);\n    }\n    endGame(winner) {\n        this.winner = winner;\n        this.gameState = 'gameover';\n        this.elements.startBtn.textContent = 'Nouvelle Partie';\n    }\n}\n// Initialize game when DOM is loaded\ndocument.addEventListener('DOMContentLoaded', () => {\n    new PongGame('game-canvas');\n});\n// Add CSS for scoring animation\nconst style = document.createElement('style');\nstyle.textContent = `\n    .scoring {\n        animation: scoreFlash 0.5s ease-out;\n    }\n    \n    @keyframes scoreFlash {\n        0% { box-shadow: 0 0 0 rgba(59, 130, 246, 0); }\n        50% { box-shadow: 0 0 20px rgba(59, 130, 246, 0.8); }\n        100% { box-shadow: 0 0 0 rgba(59, 130, 246, 0); }\n    }\n`;\ndocument.head.appendChild(style);\n\n\n//# sourceURL=webpack://ft-transcendence-frontend/./src/ts/game.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/ts/game.ts"]();
/******/ 	
/******/ })()
;