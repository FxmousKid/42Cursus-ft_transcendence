/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/ts/game.ts":
/*!************************!*\
  !*** ./src/ts/game.ts ***!
  \************************/
/***/ (() => {

eval("\n// ts/game.ts - Simplified Pong Game Implementation with TypeScript\n// Initialize the game when DOM is loaded\ndocument.addEventListener('DOMContentLoaded', function () {\n    // Game canvas and context\n    const canvas = document.getElementById('game-canvas');\n    const ctx = canvas.getContext('2d');\n    // Game constants\n    const WINNING_SCORE = 10;\n    const BALL_SPEED = 8; // Increased ball speed for better responsiveness\n    const PADDLE_SPEED = 12; // Increased paddle speed\n    // Performance tracking\n    let lastTime = 0;\n    let fpsCounter = 0;\n    let fpsTimer = 0;\n    let currentFps = 0;\n    const ball = {\n        x: canvas.width / 2,\n        y: canvas.height / 2,\n        radius: 10,\n        velocityX: 0, // Will be set in resetBall()\n        velocityY: 0, // Will be set in resetBall()\n        speed: BALL_SPEED,\n        color: 'white'\n    };\n    const paddleWidth = 10;\n    const paddleHeight = 100;\n    const paddleOffset = 20;\n    const leftPaddle = {\n        x: paddleOffset,\n        y: (canvas.height - paddleHeight) / 2,\n        width: paddleWidth,\n        height: paddleHeight,\n        score: 0,\n        color: 'white',\n        moveUp: false,\n        moveDown: false,\n        speed: PADDLE_SPEED\n    };\n    const rightPaddle = {\n        x: canvas.width - paddleOffset - paddleWidth,\n        y: (canvas.height - paddleHeight) / 2,\n        width: paddleWidth,\n        height: paddleHeight,\n        score: 0,\n        color: 'white',\n        moveUp: false,\n        moveDown: false,\n        speed: PADDLE_SPEED\n    };\n    // Game state\n    let gameRunning = false;\n    let gamePaused = false;\n    let gameOver = false;\n    let winner = '';\n    // DOM elements\n    const startButton = document.getElementById('start-button');\n    const resetButton = document.getElementById('reset-button');\n    const leftScoreDisplay = document.getElementById('player-left-score');\n    const rightScoreDisplay = document.getElementById('player-right-score');\n    // Event listeners for paddles\n    document.addEventListener('keydown', function (event) {\n        if (gameOver)\n            return; // Don't allow controls if game is over\n        // Left paddle (Q - up, W - down)\n        if (event.code === 'KeyQ') {\n            leftPaddle.moveUp = true;\n        }\n        else if (event.code === 'KeyW') {\n            leftPaddle.moveDown = true;\n        }\n        // Right paddle (Left arrow - up, Right arrow - down)\n        if (event.code === 'ArrowLeft') {\n            rightPaddle.moveUp = true;\n        }\n        else if (event.code === 'ArrowRight') {\n            rightPaddle.moveDown = true;\n        }\n        // Add pause toggle on 'P' key press\n        if (event.code === 'KeyP' && gameRunning) {\n            gamePaused = !gamePaused;\n            if (gamePaused) {\n                startButton.textContent = \"Reprendre\";\n            }\n            else {\n                startButton.textContent = \"Pause\";\n            }\n        }\n    });\n    document.addEventListener('keyup', function (event) {\n        // Left paddle\n        if (event.code === 'KeyQ') {\n            leftPaddle.moveUp = false;\n        }\n        else if (event.code === 'KeyW') {\n            leftPaddle.moveDown = false;\n        }\n        // Right paddle\n        if (event.code === 'ArrowLeft') {\n            rightPaddle.moveUp = false;\n        }\n        else if (event.code === 'ArrowRight') {\n            rightPaddle.moveDown = false;\n        }\n    });\n    // Button controls\n    startButton.addEventListener('click', function () {\n        if (gameOver) {\n            // If game is over, reset everything and start a new game\n            gameOver = false;\n            winner = '';\n            resetGame();\n            startGame();\n        }\n        else if (!gameRunning) {\n            // Start the game if it's not running\n            gameRunning = true;\n            gamePaused = false;\n            startButton.textContent = \"Pause\";\n            startGame();\n        }\n        else {\n            // Toggle pause if the game is already running\n            gamePaused = !gamePaused;\n            if (gamePaused) {\n                // Game is now paused\n                startButton.textContent = \"Reprendre\";\n            }\n            else {\n                // Game is now resumed\n                startButton.textContent = \"Pause\";\n            }\n        }\n    });\n    resetButton.addEventListener('click', function () {\n        // Reset the game\n        resetGame();\n        // Reset game state\n        gameOver = false;\n        winner = '';\n        // Reset the pause state and button appearance if game is running\n        if (gameRunning) {\n            gamePaused = false;\n            startButton.textContent = \"Pause\";\n        }\n    });\n    // Drawing functions\n    function drawRect(x, y, width, height, color) {\n        ctx.fillStyle = color;\n        ctx.fillRect(x, y, width, height);\n    }\n    function drawCircle(x, y, radius, color) {\n        ctx.fillStyle = color;\n        ctx.beginPath();\n        ctx.arc(x, y, radius, 0, Math.PI * 2, false);\n        ctx.closePath();\n        ctx.fill();\n    }\n    function drawNet() {\n        const netWidth = 2;\n        const netHeight = 10;\n        const netGap = 15;\n        for (let y = 0; y <= canvas.height; y += netHeight + netGap) {\n            drawRect(canvas.width / 2 - netWidth / 2, y, netWidth, netHeight, 'rgba(255, 255, 255, 0.5)');\n        }\n    }\n    function drawPaddle(paddle) {\n        drawRect(paddle.x, paddle.y, paddle.width, paddle.height, paddle.color);\n    }\n    function drawScore() {\n        leftScoreDisplay.textContent = leftPaddle.score.toString();\n        rightScoreDisplay.textContent = rightPaddle.score.toString();\n    }\n    // Collision detection\n    function collision(ball, paddle) {\n        // Check if ball coordinates are within paddle boundaries\n        return (ball.x + ball.radius > paddle.x &&\n            ball.x - ball.radius < paddle.x + paddle.width &&\n            ball.y + ball.radius > paddle.y &&\n            ball.y - ball.radius < paddle.y + paddle.height);\n    }\n    // Game logic\n    function update() {\n        // Don't update the game if it's not running, paused, or over\n        if (!gameRunning || gamePaused || gameOver)\n            return;\n        // Move left paddle\n        if (leftPaddle.moveUp && leftPaddle.y > 0) {\n            leftPaddle.y -= leftPaddle.speed;\n        }\n        else if (leftPaddle.moveDown && leftPaddle.y + leftPaddle.height < canvas.height) {\n            leftPaddle.y += leftPaddle.speed;\n        }\n        // Move right paddle\n        if (rightPaddle.moveUp && rightPaddle.y > 0) {\n            rightPaddle.y -= rightPaddle.speed;\n        }\n        else if (rightPaddle.moveDown && rightPaddle.y + rightPaddle.height < canvas.height) {\n            rightPaddle.y += rightPaddle.speed;\n        }\n        // Update ball position\n        ball.x += ball.velocityX;\n        ball.y += ball.velocityY;\n        // Wall collision (top and bottom)\n        if (ball.y + ball.radius > canvas.height || ball.y - ball.radius < 0) {\n            ball.velocityY = -ball.velocityY;\n        }\n        // Determine which paddle is being hit by the ball\n        let player = (ball.x < canvas.width / 2) ? leftPaddle : rightPaddle;\n        // If the ball hits a paddle\n        if (collision(ball, player)) {\n            // Where the ball hit the paddle\n            let collidePoint = ball.y - (player.y + player.height / 2);\n            // Normalize the value of collidePoint\n            collidePoint = collidePoint / (player.height / 2);\n            // Calculate angle in radians (simplified)\n            let angleRad = collidePoint * (Math.PI / 4);\n            // X direction of the ball\n            let direction = (ball.x < canvas.width / 2) ? 1 : -1;\n            // Set velocity based on direction and angle\n            ball.velocityX = direction * ball.speed * Math.cos(angleRad);\n            ball.velocityY = ball.speed * Math.sin(angleRad);\n        }\n        // Scoring - ball goes beyond paddles\n        if (ball.x - ball.radius < 0) {\n            // Right player scores\n            rightPaddle.score++;\n            // Check for win\n            if (rightPaddle.score >= WINNING_SCORE) {\n                gameOver = true;\n                winner = 'Joueur 2';\n                startButton.textContent = \"Nouvelle Partie\";\n            }\n            else {\n                resetBall();\n            }\n        }\n        else if (ball.x + ball.radius > canvas.width) {\n            // Left player scores\n            leftPaddle.score++;\n            // Check for win\n            if (leftPaddle.score >= WINNING_SCORE) {\n                gameOver = true;\n                winner = 'Joueur 1';\n                startButton.textContent = \"Nouvelle Partie\";\n            }\n            else {\n                resetBall();\n            }\n        }\n        // Update score display\n        drawScore();\n    }\n    function resetBall() {\n        ball.x = canvas.width / 2;\n        ball.y = canvas.height / 2;\n        // Set a random angle, but avoid too vertical trajectories\n        let angle = (Math.random() * 0.5 + 0.25) * Math.PI; // angle between PI/4 and 3PI/4\n        // 50% chance of going left or right\n        if (Math.random() < 0.5) {\n            angle = Math.PI - angle; // Reflect angle to go left\n        }\n        // Calculate velocity components based on speed and angle\n        ball.velocityX = ball.speed * Math.cos(angle);\n        ball.velocityY = ball.speed * Math.sin(angle) * (Math.random() < 0.5 ? 1 : -1); // Random up/down\n    }\n    function resetGame() {\n        // Reset scores\n        leftPaddle.score = 0;\n        rightPaddle.score = 0;\n        // Reset paddles position\n        leftPaddle.y = (canvas.height - leftPaddle.height) / 2;\n        rightPaddle.y = (canvas.height - rightPaddle.height) / 2;\n        // Reset ball and its velocity\n        resetBall();\n        // Update score display\n        drawScore();\n        // Redraw the game\n        render();\n    }\n    function render() {\n        // Clear the canvas - use clearRect for better performance\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        drawRect(0, 0, canvas.width, canvas.height, '#111827');\n        // Draw the net\n        drawNet();\n        // Draw paddles\n        drawPaddle(leftPaddle);\n        drawPaddle(rightPaddle);\n        // Draw the ball\n        drawCircle(ball.x, ball.y, ball.radius, ball.color);\n        // Display FPS counter (for development)\n        ctx.fillStyle = 'white';\n        ctx.font = '12px Arial';\n        ctx.fillText(`FPS: ${currentFps}`, canvas.width - 70, 20);\n        // Display game information\n        if (gameOver) {\n            // Game over overlay\n            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            ctx.fillStyle = 'white';\n            ctx.font = 'bold 48px Arial';\n            ctx.textAlign = 'center';\n            ctx.fillText('PARTIE TERMINÉE', canvas.width / 2, canvas.height / 2 - 50);\n            ctx.font = 'bold 32px Arial';\n            ctx.fillText(`${winner} gagne!`, canvas.width / 2, canvas.height / 2 + 10);\n            ctx.font = '20px Arial';\n            ctx.fillText('Cliquez sur \"Nouvelle Partie\" pour recommencer', canvas.width / 2, canvas.height / 2 + 60);\n            ctx.textAlign = 'left'; // Reset text alignment\n        }\n        else if (gamePaused && gameRunning) {\n            // Pause overlay\n            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            ctx.fillStyle = 'white';\n            ctx.font = 'bold 32px Arial';\n            ctx.textAlign = 'center';\n            ctx.fillText('PAUSE', canvas.width / 2, canvas.height / 2);\n            ctx.textAlign = 'left'; // Reset text alignment\n        }\n    }\n    function gameLoop(timestamp = 0) {\n        // Calculate delta time for smooth animation\n        const deltaTime = timestamp - lastTime;\n        lastTime = timestamp;\n        // Update FPS counter\n        fpsCounter++;\n        fpsTimer += deltaTime;\n        if (fpsTimer >= 1000) {\n            currentFps = fpsCounter;\n            fpsCounter = 0;\n            fpsTimer -= 1000;\n        }\n        update();\n        render();\n        requestAnimationFrame(gameLoop);\n    }\n    function startGame() {\n        resetGame();\n        gameRunning = true;\n        gamePaused = false;\n        gameOver = false;\n        winner = '';\n        startButton.textContent = \"Pause\";\n        lastTime = performance.now();\n        requestAnimationFrame(gameLoop);\n    }\n    // Initialize the game\n    resetGame();\n});\n\n\n//# sourceURL=webpack://ft-transcendence-frontend/./src/ts/game.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/ts/game.ts"]();
/******/ 	
/******/ })()
;